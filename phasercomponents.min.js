var spine = {
    radDeg: 180 / Math.PI,
    degRad: Math.PI / 180,
    Float32Array: "undefined" == typeof Float32Array ? Array : Float32Array,
    Uint32Array: "undefined" == typeof Uint32Array ? Array : Uint32Array,
    Uint16Array: "undefined" == typeof Uint16Array ? Array : Uint16Array
};
spine.temp = new spine.Float32Array(2), spine.BoneData = function(t, e) {
    this.name = t, this.parent = e
}, spine.BoneData.prototype = {
    length: 0,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    inheritScale: !0,
    inheritRotation: !0
}, spine.BlendMode = {
    normal: 0,
    additive: 1,
    multiply: 2,
    screen: 3
}, spine.SlotData = function(t, e) {
    this.name = t, this.boneData = e
}, spine.SlotData.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    attachmentName: null,
    blendMode: spine.BlendMode.normal
}, spine.IkConstraintData = function(t) {
    this.name = t, this.bones = []
}, spine.IkConstraintData.prototype = {
    target: null,
    bendDirection: 1,
    mix: 1
}, spine.TransformConstraintData = function(t) {
    this.name = t
}, spine.TransformConstraintData.prototype = {
    bone: null,
    target: null,
    translateMix: 1,
    x: 0,
    y: 0
}, spine.Bone = function(t, e, i) {
    this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose()
}, spine.Bone.yDown = !1, spine.Bone.prototype = {
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    a: 0,
    b: 0,
    worldX: 0,
    c: 0,
    d: 0,
    worldY: 0,
    worldSignX: 1,
    worldSignY: 1,
    update: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransformWith: function() {
        this.updateWorldTransform(this.x, this.y, this.rotation, this.scaleX, this.scaleY)
    },
    updateWorldTransform: function(t, e, i, r, a) {
        this.appliedRotation = i, this.appliedScaleX = r, this.appliedScaleY = a, i *= spine.degRad;
        var n = Math.cos(i),
            s = Math.sin(i),
            o = n * r,
            h = -s * a,
            l = s * r,
            c = n * a,
            p = this.parent;
        if (!p) {
            var m = this.skeleton;
            return m.flipX && (t = -t, o = -o, h = -h), m.flipY != spine.Bone.yDown && (e = -e, l = -l, c = -c), this.a = o, this.b = h, this.c = l, this.d = c, this.worldX = t, this.worldY = e, this.worldSignX = r < 0 ? -1 : 1, void(this.worldSignY = a < 0 ? -1 : 1)
        }
        var u = p.a,
            d = p.b,
            f = p.c,
            g = p.d;
        if (this.worldX = u * t + d * e + p.worldX, this.worldY = f * t + g * e + p.worldY, this.worldSignX = p.worldSignX * (r < 0 ? -1 : 1), this.worldSignY = p.worldSignY * (a < 0 ? -1 : 1), this.data.inheritRotation && this.data.inheritScale) this.a = u * o + d * l, this.b = u * h + d * c, this.c = f * o + g * l, this.d = f * h + g * c;
        else {
            if (this.data.inheritRotation) {
                u = 1, d = 0, f = 0, g = 1;
                do {
                    i = p.appliedRotation * spine.degRad;
                    var v = u * (n = Math.cos(i)) + d * (s = Math.sin(i));
                    if (d = u * -s + d * n, u = v, v = f * n + g * s, g = f * -s + g * n, f = v, !p.data.inheritRotation) break;
                    p = p.parent
                } while (p);
                this.a = u * o + d * l, this.b = u * h + d * c, this.c = f * o + g * l, this.d = f * h + g * c
            } else if (this.data.inheritScale) {
                u = 1, d = 0, f = 0, g = 1;
                do {
                    i = p.appliedRotation * spine.degRad, n = Math.cos(i), s = Math.sin(i);
                    var y = p.appliedScaleX,
                        P = p.appliedScaleY,
                        S = n * y,
                        x = -s * P,
                        b = s * y,
                        w = n * P;
                    if (v = u * S + d * b, d = u * x + d * w, u = v, v = f * S + g * b, g = f * x + g * w, f = v, y < 0 && (i = -i), v = u * (n = Math.cos(-i)) + d * (s = Math.sin(-i)), d = u * -s + d * n, u = v, v = f * n + g * s, g = f * -s + g * n, f = v, !p.data.inheritScale) break;
                    p = p.parent
                } while (p);
                this.a = u * o + d * l, this.b = u * h + d * c, this.c = f * o + g * l, this.d = f * h + g * c
            } else this.a = o, this.b = h, this.c = l, this.d = c;
            this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY != spine.Bone.yDown && (this.c = -this.c, this.d = -this.d)
        }
    },
    setToSetupPose: function() {
        var t = this.data;
        this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY
    },
    getWorldRotationX: function() {
        return Math.atan2(this.c, this.a) * spine.radDeg
    },
    getWorldRotationY: function() {
        return Math.atan2(this.d, this.b) * spine.radDeg
    },
    getWorldScaleX: function() {
        return Math.sqrt(this.a * this.a + this.b * this.b) * this.worldSignX
    },
    getWorldScaleY: function() {
        return Math.sqrt(this.c * this.c + this.d * this.d) * this.worldSignY
    },
    worldToLocal: function(t) {
        var e = t[0] - this.worldX,
            i = t[1] - this.worldY,
            r = this.a,
            a = this.b,
            n = this.c,
            s = this.d,
            o = 1 / (r * s - a * n);
        return t[0] = e * s * o - i * a * o, t[1] = i * r * o - e * n * o, t
    },
    localToWorld: function(t) {
        var e = t[0],
            i = t[1];
        return t[0] = e * this.a + i * this.b + this.worldX, t[1] = e * this.c + i * this.d + this.worldY, t
    }
}, spine.Slot = function(t, e) {
    this.data = t, this.bone = e, this.attachmentVertices = new spine.Float32Array, this.setToSetupPose()
}, spine.Slot.prototype = {
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    _attachmentTime: 0,
    attachment: null,
    setAttachment: function(t) {
        this.attachment != t && (this.attachment = t, this._attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0)
    },
    setAttachmentTime: function(t) {
        this._attachmentTime = this.bone.skeleton.time - t
    },
    getAttachmentTime: function() {
        return this.bone.skeleton.time - this._attachmentTime
    },
    setToSetupPose: function() {
        var t = this.data;
        if (this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, t.attachmentName) {
            for (var e = this.bone.skeleton.data.slots, i = 0, r = e.length; i < r; i++)
                if (e[i] == t) {
                    this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachmentBySlotIndex(i, t.attachmentName));
                    break
                }
        } else this.setAttachment(null)
    }
}, spine.IkConstraint = function(t, e) {
    this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = [];
    for (var i = 0, r = t.bones.length; i < r; i++) this.bones[i] = e.findBone(t.bones[i].name);
    this.target = e.findBone(t.target.name)
}, spine.IkConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var t = this.target,
            e = this.bones;
        switch (e.length) {
            case 1:
                spine.IkConstraint.apply1(e[0], t.worldX, t.worldY, this.mix);
                break;
            case 2:
                spine.IkConstraint.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix)
        }
    }
}, spine.IkConstraint.apply1 = function(t, e, i, r) {
    var a = t.parent ? t.parent.getWorldRotationX() : 0,
        n = t.rotation,
        s = Math.atan2(i - t.worldY, e - t.worldX) * spine.radDeg - a;
    t.worldSignX != t.worldSignY != (t.skeleton.flipX != (t.skeleton.flipY != spine.Bone.yDown)) && (s = 360 - s), s > 180 ? s -= 360 : s < -180 && (s += 360), t.updateWorldTransform(t.x, t.y, n + (s - n) * r, t.appliedScaleX, t.appliedScaleY)
}, spine.IkConstraint.apply2 = function(t, e, i, r, a, n) {
    if (0 != n) {
        var s, o, h, l = t.x,
            c = t.y,
            p = t.appliedScaleX,
            m = t.appliedScaleY;
        p < 0 ? (p = -p, s = 180, h = -1) : (s = 0, h = 1), m < 0 && (m = -m, h = -h);
        var u = e.x,
            d = e.y,
            f = e.appliedScaleX,
            g = Math.abs(p - m) <= 1e-4;
        g || 0 == d || (e.worldX = t.a * u + t.worldX, e.worldY = t.c * u + t.worldY, d = 0), f < 0 ? (f = -f, o = 180) : o = 0;
        var v, y, P, S, x = t.parent;
        if (x) {
            var b = x.a,
                w = x.b,
                A = x.c,
                T = 1 / (b * (D = x.d) - w * A),
                M = x.worldX,
                k = x.worldY;
            v = ((H = i - M) * D - (G = r - k) * w) * T - l, y = (G * b - H * A) * T - c, P = ((H = e.worldX - M) * D - (G = e.worldY - k) * w) * T - l, S = (G * b - H * A) * T - c
        } else v = i - l, y = r - c, P = e.worldX - l, S = e.worldY - c;
        var C, O, R = Math.sqrt(P * P + S * S),
            I = e.data.length * f;
        t: if (g) {
            var E = (v * v + y * y - R * R - (I *= p) * I) / (2 * R * I);
            E < -1 ? E = -1 : E > 1 && (E = 1), O = Math.acos(E) * a, b = R + I * E;
            var B = I * Math.sin(O);
            C = Math.atan2(y * b - v * B, v * b + y * B)
        } else {
            b = p * I, w = m * I;
            var D, V = Math.atan2(y, v),
                _ = b * b,
                F = w * w,
                X = v * v + y * y,
                L = F * (R * R) + _ * X - _ * F,
                Y = -2 * F * R,
                U = F - _;
            if ((D = Y * Y - 4 * U * L) >= 0) {
                var N = Math.sqrt(D);
                Y < 0 && (N = -N);
                var Z = (N = -(Y + N) / 2) / U,
                    W = L / N,
                    j = Math.abs(Z) < Math.abs(W) ? Z : W;
                if (j * j <= X) {
                    var G = Math.sqrt(X - j * j) * a;
                    C = V - Math.atan2(G, j), O = Math.atan2(G / m, (j - R) / p);
                    break t
                }
            }
            var H, z = 0,
                q = Number.MAX_VALUE,
                K = 0,
                J = 0,
                $ = 0,
                Q = 0,
                tt = 0,
                et = 0,
                it = (H = R + b) * H;
            it > Q && ($ = 0, Q = it, tt = H), (it = (H = R - b) * H) < q && (z = Math.PI, q = it, K = H);
            var rt = Math.acos(-b * R / (_ - F));
            (it = (H = b * Math.cos(rt) + R) * H + (G = w * Math.sin(rt)) * G) < q && (z = rt, q = it, K = H, J = G), it > Q && ($ = rt, Q = it, tt = H, et = G), X <= (q + Q) / 2 ? (C = V - Math.atan2(J * a, K), O = z * a) : (C = V - Math.atan2(et * a, tt), O = $ * a)
        }
        var at = Math.atan2(d, u) * h;
        (C = (C - at) * spine.radDeg + s) > 180 ? C -= 360 : C < -180 && (C += 360), (O = (O + at) * spine.radDeg * h + o) > 180 ? O -= 360 : O < -180 && (O += 360);
        var nt = t.rotation;
        t.updateWorldTransform(l, c, nt + (C - nt) * n, t.appliedScaleX, t.appliedScaleY), nt = e.rotation, e.updateWorldTransform(u, d, nt + (O - nt) * n, e.appliedScaleX, e.appliedScaleY)
    }
}, spine.TransformConstraint = function(t, e) {
    this.data = t, this.translateMix = t.translateMix, this.x = t.x, this.y = t.y, this.bone = e.findBone(t.bone.name), this.target = e.findBone(t.target.name)
}, spine.TransformConstraint.prototype = {
    apply: function() {
        this.update()
    },
    update: function() {
        var t = this.translateMix;
        if (t > 0) {
            var e = spine.temp;
            e[0] = x, e[1] = y, this.target.localToWorld(e);
            var i = this.bone;
            i.worldX += (e[0] - i.worldX) * t, i.worldY += (e[1] - i.worldY) * t
        }
    }
}, spine.Skin = function(t) {
    this.name = t, this.attachments = {}
}, spine.Skin.prototype = {
    addAttachment: function(t, e, i) {
        this.attachments[t + ":" + e] = i
    },
    getAttachment: function(t, e) {
        return this.attachments[t + ":" + e]
    },
    _attachAll: function(t, e) {
        for (var i in e.attachments) {
            var r = i.indexOf(":"),
                a = parseInt(i.substring(0, r)),
                n = i.substring(r + 1),
                s = t.slots[a];
            if (s.attachment && s.attachment.name == n) {
                var o = this.getAttachment(a, n);
                o && s.setAttachment(o)
            }
        }
    }
}, spine.Animation = function(t, e, i) {
    this.name = t, this.timelines = e, this.duration = i
}, spine.Animation.prototype = {
    apply: function(t, e, i, r, a) {
        r && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
        for (var n = this.timelines, s = 0, o = n.length; s < o; s++) n[s].apply(t, e, i, a, 1)
    },
    mix: function(t, e, i, r, a, n) {
        r && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration));
        for (var s = this.timelines, o = 0, h = s.length; o < h; o++) s[o].apply(t, e, i, a, n)
    }
}, spine.Animation.binarySearch = function(t, e, i) {
    var r = 0,
        a = Math.floor(t.length / i) - 2;
    if (!a) return i;
    for (var n = a >>> 1;;) {
        if (t[(n + 1) * i] <= e ? r = n + 1 : a = n, r == a) return (r + 1) * i;
        n = r + a >>> 1
    }
}, spine.Animation.binarySearch1 = function(t, e) {
    var i = 0,
        r = t.length - 2;
    if (!r) return 1;
    for (var a = r >>> 1;;) {
        if (t[a + 1] <= e ? i = a + 1 : r = a, i == r) return i + 1;
        a = i + r >>> 1
    }
}, spine.Animation.linearSearch = function(t, e, i) {
    for (var r = 0, a = t.length - i; r <= a; r += i)
        if (t[r] > e) return r;
    return -1
}, spine.Curves = function(t) {
    var e = 19 * (t - 1);
    this.curves = new spine.Float32Array(e), this.curves.length = e
}, spine.Curves.prototype = {
    setLinear: function(t) {
        this.curves[19 * t] = 0
    },
    setStepped: function(t) {
        this.curves[19 * t] = 1
    },
    setCurve: function(t, e, i, r, a) {
        var n = .1 * .1,
            s = .1 * n,
            o = 3 * n,
            h = 6 * n,
            l = 6 * s,
            c = 2 * -e + r,
            p = 2 * -i + a,
            m = 3 * (e - r) + 1,
            u = 3 * (i - a) + 1,
            d = e * (3 * .1) + c * o + m * s,
            f = i * (3 * .1) + p * o + u * s,
            g = c * h + m * l,
            v = p * h + u * l,
            y = m * l,
            P = u * l,
            S = 19 * t,
            x = this.curves;
        x[S++] = 2;
        for (var b = d, w = f, A = S + 19 - 1; S < A; S += 2) x[S] = b, x[S + 1] = w, d += g, f += v, g += y, v += P, b += d, w += f
    },
    getCurvePercent: function(t, e) {
        e = e < 0 ? 0 : e > 1 ? 1 : e;
        var i = this.curves,
            r = 19 * t,
            a = i[r];
        if (0 === a) return e;
        if (1 == a) return 0;
        for (var n = 0, s = ++r, o = r + 19 - 1; r < o; r += 2)
            if ((n = i[r]) >= e) {
                var h, l;
                return r == s ? (h = 0, l = 0) : (h = i[r - 2], l = i[r - 1]), l + (i[r + 1] - l) * (e - h) / (n - h)
            } var c = i[r - 1];
        return c + (1 - c) * (e - n) / (1 - n)
    }
}, spine.RotateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(2 * t), this.frames.length = 2 * t
}, spine.RotateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 2
    },
    setFrame: function(t, e, i) {
        t *= 2, this.frames[t] = e, this.frames[t + 1] = i
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s = t.bones[this.boneIndex];
            if (i >= n[n.length - 2]) {
                for (var o = s.data.rotation + n[n.length - 1] - s.rotation; o > 180;) o -= 360;
                for (; o < -180;) o += 360;
                return void(s.rotation += o * a)
            }
            var h = spine.Animation.binarySearch(n, i, 2),
                l = n[h - 1],
                c = n[h],
                p = 1 - (i - c) / (n[h - 2] - c);
            for (p = this.curves.getCurvePercent(h / 2 - 1, p), o = n[h + 1] - l; o > 180;) o -= 360;
            for (; o < -180;) o += 360;
            for (o = s.data.rotation + (l + o * p) - s.rotation; o > 180;) o -= 360;
            for (; o < -180;) o += 360;
            s.rotation += o * a
        }
    }
}, spine.TranslateTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.TranslateTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, r) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = r
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s = t.bones[this.boneIndex];
            if (i >= n[n.length - 3]) return s.x += (s.data.x + n[n.length - 2] - s.x) * a, void(s.y += (s.data.y + n[n.length - 1] - s.y) * a);
            var o = spine.Animation.binarySearch(n, i, 3),
                h = n[o - 2],
                l = n[o - 1],
                c = n[o],
                p = 1 - (i - c) / (n[o + -3] - c);
            p = this.curves.getCurvePercent(o / 3 - 1, p), s.x += (s.data.x + h + (n[o + 1] - h) * p - s.x) * a, s.y += (s.data.y + l + (n[o + 2] - l) * p - s.y) * a
        }
    }
}, spine.ScaleTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.ScaleTimeline.prototype = {
    boneIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, r) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = r
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s = t.bones[this.boneIndex];
            if (i >= n[n.length - 3]) return s.scaleX += (s.data.scaleX * n[n.length - 2] - s.scaleX) * a, void(s.scaleY += (s.data.scaleY * n[n.length - 1] - s.scaleY) * a);
            var o = spine.Animation.binarySearch(n, i, 3),
                h = n[o - 2],
                l = n[o - 1],
                c = n[o],
                p = 1 - (i - c) / (n[o + -3] - c);
            p = this.curves.getCurvePercent(o / 3 - 1, p), s.scaleX += (s.data.scaleX * (h + (n[o + 1] - h) * p) - s.scaleX) * a, s.scaleY += (s.data.scaleY * (l + (n[o + 2] - l) * p) - s.scaleY) * a
        }
    }
}, spine.ColorTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(5 * t), this.frames.length = 5 * t
}, spine.ColorTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 5
    },
    setFrame: function(t, e, i, r, a, n) {
        t *= 5, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = r, this.frames[t + 3] = a, this.frames[t + 4] = n
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s, o, h, l;
            if (i >= n[n.length - 5]) {
                var c = n.length - 1;
                s = n[c - 3], o = n[c - 2], h = n[c - 1], l = n[c]
            } else {
                var p = spine.Animation.binarySearch(n, i, 5),
                    m = n[p - 4],
                    u = n[p - 3],
                    d = n[p - 2],
                    f = n[p - 1],
                    g = n[p],
                    v = 1 - (i - g) / (n[p - 5] - g);
                v = this.curves.getCurvePercent(p / 5 - 1, v), s = m + (n[p + 1] - m) * v, o = u + (n[p + 2] - u) * v, h = d + (n[p + 3] - d) * v, l = f + (n[p + 4] - f) * v
            }
            var y = t.slots[this.slotIndex];
            a < 1 ? (y.r += (s - y.r) * a, y.g += (o - y.g) * a, y.b += (h - y.b) * a, y.a += (l - y.a) * a) : (y.r = s, y.g = o, y.b = h, y.a = l)
        }
    }
}, spine.AttachmentTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.attachmentNames = [], this.attachmentNames.length = t
}, spine.AttachmentTimeline.prototype = {
    slotIndex: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.attachmentNames[t] = i
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (i < n[0]) e > i && this.apply(t, e, Number.MAX_VALUE, null, 0);
        else {
            e > i && (e = -1);
            var s = i >= n[n.length - 1] ? n.length - 1 : spine.Animation.binarySearch1(n, i) - 1;
            if (!(n[s] < e)) {
                var o = this.attachmentNames[s];
                t.slots[this.slotIndex].setAttachment(o ? t.getAttachmentBySlotIndex(this.slotIndex, o) : null)
            }
        }
    }
}, spine.EventTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.events = [], this.events.length = t
}, spine.EventTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e) {
        this.frames[t] = e.time, this.events[t] = e
    },
    apply: function(t, e, i, r, a) {
        if (r) {
            var n = this.frames,
                s = n.length;
            if (e > i) this.apply(t, e, Number.MAX_VALUE, r, a), e = -1;
            else if (e >= n[s - 1]) return;
            if (!(i < n[0])) {
                var o;
                if (e < n[0]) o = 0;
                else
                    for (var h = n[o = spine.Animation.binarySearch1(n, e)]; o > 0 && n[o - 1] == h;) o--;
                for (var l = this.events; o < s && i >= n[o]; o++) r[r.length] = l[o]
            }
        }
    }
}, spine.DrawOrderTimeline = function(t) {
    this.frames = new spine.Float32Array(t), this.frames.length = t, this.drawOrders = [], this.drawOrders.length = t
}, spine.DrawOrderTimeline.prototype = {
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.drawOrders[t] = i
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s;
            s = i >= n[n.length - 1] ? n.length - 1 : spine.Animation.binarySearch1(n, i) - 1;
            var o = t.drawOrder,
                h = t.slots,
                l = this.drawOrders[s];
            if (l)
                for (var c = 0, p = l.length; c < p; c++) o[c] = t.slots[l[c]];
            else
                for (c = 0, p = h.length; c < p; c++) o[c] = h[c]
        }
    }
}, spine.FfdTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(t), this.frames.length = t, this.frameVertices = [], this.frameVertices.length = t
}, spine.FfdTimeline.prototype = {
    slotIndex: 0,
    attachment: 0,
    getFrameCount: function() {
        return this.frames.length
    },
    setFrame: function(t, e, i) {
        this.frames[t] = e, this.frameVertices[t] = i
    },
    apply: function(t, e, i, r, a) {
        var n = t.slots[this.slotIndex],
            s = n.attachment;
        if (s && (s == this.attachment || s.inheritFFD && s.parentMesh == this.attachment)) {
            var o = this.frames;
            if (!(i < o[0])) {
                var h = this.frameVertices,
                    l = h[0].length,
                    c = n.attachmentVertices;
                if (c.length != l && (n.attachmentVertices = c = new spine.Float32Array(l), a = 1), i >= o[o.length - 1]) {
                    var p = h[o.length - 1];
                    if (a < 1)
                        for (var m = 0; m < l; m++) c[m] += (p[m] - c[m]) * a;
                    else
                        for (m = 0; m < l; m++) c[m] = p[m]
                } else {
                    var u = spine.Animation.binarySearch1(o, i),
                        d = o[u],
                        f = 1 - (i - d) / (o[u - 1] - d);
                    f = this.curves.getCurvePercent(u - 1, f < 0 ? 0 : f > 1 ? 1 : f);
                    var g = h[u - 1],
                        v = h[u];
                    if (a < 1)
                        for (m = 0; m < l; m++) {
                            var y = g[m];
                            c[m] += (y + (v[m] - y) * f - c[m]) * a
                        } else
                            for (m = 0; m < l; m++) y = g[m], c[m] = y + (v[m] - y) * f
                }
            }
        }
    }
}, spine.IkConstraintTimeline = function(t) {
    this.curves = new spine.Curves(t), this.frames = new spine.Float32Array(3 * t), this.frames.length = 3 * t
}, spine.IkConstraintTimeline.prototype = {
    ikConstraintIndex: 0,
    getFrameCount: function() {
        return this.frames.length / 3
    },
    setFrame: function(t, e, i, r) {
        t *= 3, this.frames[t] = e, this.frames[t + 1] = i, this.frames[t + 2] = r
    },
    apply: function(t, e, i, r, a) {
        var n = this.frames;
        if (!(i < n[0])) {
            var s = t.ikConstraints[this.ikConstraintIndex];
            if (i >= n[n.length - 3]) return s.mix += (n[n.length - 2] - s.mix) * a, void(s.bendDirection = n[n.length - 1]);
            var o = spine.Animation.binarySearch(n, i, 3),
                h = n[o + -2],
                l = n[o],
                c = 1 - (i - l) / (n[o + -3] - l);
            c = this.curves.getCurvePercent(o / 3 - 1, c);
            var p = h + (n[o + 1] - h) * c;
            s.mix += (p - s.mix) * a, s.bendDirection = n[o + -1]
        }
    }
}, spine.SkeletonData = function() {
    this.bones = [], this.slots = [], this.skins = [], this.events = [], this.animations = [], this.ikConstraints = [], this.transformConstraints = []
}, spine.SkeletonData.prototype = {
    name: null,
    defaultSkin: null,
    width: 0,
    height: 0,
    version: null,
    hash: null,
    findBone: function(t) {
        for (var e = this.bones, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return i;
        return -1
    },
    findSlot: function(t) {
        for (var e = this.slots, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return i;
        return -1
    },
    findSkin: function(t) {
        for (var e = this.skins, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findEvent: function(t) {
        for (var e = this.events, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findAnimation: function(t) {
        for (var e = this.animations, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    findTransformConstraints: function(t) {
        for (var e = this.transformConstraints, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    }
}, spine.Skeleton = function(t) {
    this.data = t, this.bones = [];
    for (var e = 0, i = t.bones.length; e < i; e++) {
        var r = t.bones[e],
            a = r.parent ? this.bones[t.bones.indexOf(r.parent)] : null;
        this.bones[e] = new spine.Bone(r, this, a)
    }
    for (this.slots = [], this.drawOrder = [], e = 0, i = t.slots.length; e < i; e++) {
        var n = t.slots[e],
            s = this.bones[t.bones.indexOf(n.boneData)],
            o = new spine.Slot(n, s);
        this.slots[e] = o, this.drawOrder[e] = o
    }
    for (this.ikConstraints = [], e = 0, i = t.ikConstraints.length; e < i; e++) this.ikConstraints[e] = new spine.IkConstraint(t.ikConstraints[e], this);
    for (this.transformConstraints = [], e = 0, i = t.transformConstraints.length; e < i; e++) this.transformConstraints[e] = new spine.TransformConstraint(t.transformConstraints[e], this);
    this.cache = [], this.updateCache()
}, spine.Skeleton.prototype = {
    x: 0,
    y: 0,
    skin: null,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    time: 0,
    flipX: !1,
    flipY: !1,
    updateCache: function() {
        var t = this.bones,
            e = this.cache,
            i = this.ikConstraints,
            r = this.transformConstraints,
            a = i.length,
            n = r.length;
        e.length = 0;
        for (var s = 0, o = t.length; s < o; s++) {
            var h = t[s];
            e[e.length] = h;
            for (var l = 0; l < a; l++) {
                var c = i[l];
                if (h == c.bones[c.bones.length - 1]) {
                    e[e.length] = c;
                    break
                }
            }
        }
        for (s = 0; s < n; s++) {
            var p = r[s];
            for (l = e.length - 1; l >= 0; l--) {
                var m = e[l];
                if (m == p.bone || m == p.target) {
                    e.splice(l + 1, 0, p);
                    break
                }
            }
        }
    },
    updateWorldTransform: function() {
        for (var t = this.cache, e = 0, i = t.length; e < i; e++) t[e].update()
    },
    setToSetupPose: function() {
        this.setBonesToSetupPose(), this.setSlotsToSetupPose()
    },
    setBonesToSetupPose: function() {
        for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].setToSetupPose();
        var r = this.ikConstraints;
        for (e = 0, i = r.length; e < i; e++)(n = r[e]).bendDirection = n.data.bendDirection, n.mix = n.data.mix;
        var a = this.transformConstraints;
        for (e = 0, i = a.length; e < i; e++) {
            var n;
            (n = a[e]).translateMix = n.data.translateMix, n.x = n.data.x, n.y = n.data.y
        }
    },
    setSlotsToSetupPose: function() {
        for (var t = this.slots, e = this.drawOrder, i = 0, r = t.length; i < r; i++) e[i] = t[i], t[i].setToSetupPose(i)
    },
    getRootBone: function() {
        return this.bones.length ? this.bones[0] : null
    },
    findBone: function(t) {
        for (var e = this.bones, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findBoneIndex: function(t) {
        for (var e = this.bones, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return i;
        return -1
    },
    findSlot: function(t) {
        for (var e = this.slots, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findSlotIndex: function(t) {
        for (var e = this.slots, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return i;
        return -1
    },
    setSkinByName: function(t) {
        var e = this.data.findSkin(t);
        if (!e) throw "Skin not found: " + t;
        this.setSkin(e)
    },
    setSkin: function(t) {
        if (t)
            if (this.skin) t._attachAll(this, this.skin);
            else
                for (var e = this.slots, i = 0, r = e.length; i < r; i++) {
                    var a = e[i],
                        n = a.data.attachmentName;
                    if (n) {
                        var s = t.getAttachment(i, n);
                        s && a.setAttachment(s)
                    }
                }
        this.skin = t
    },
    getAttachmentBySlotName: function(t, e) {
        return this.getAttachmentBySlotIndex(this.data.findSlotIndex(t), e)
    },
    getAttachmentBySlotIndex: function(t, e) {
        if (this.skin) {
            var i = this.skin.getAttachment(t, e);
            if (i) return i
        }
        return this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null
    },
    setAttachment: function(t, e) {
        for (var i = this.slots, r = 0, a = i.length; r < a; r++) {
            var n = i[r];
            if (n.data.name == t) {
                var s = null;
                if (e && !(s = this.getAttachmentBySlotIndex(r, e))) throw "Attachment not found: " + e + ", for slot: " + t;
                return void n.setAttachment(s)
            }
        }
        throw "Slot not found: " + t
    },
    findIkConstraint: function(t) {
        for (var e = this.ikConstraints, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    findTransformConstraint: function(t) {
        for (var e = this.transformConstraints, i = 0, r = e.length; i < r; i++)
            if (e[i].data.name == t) return e[i];
        return null
    },
    update: function(t) {
        this.time += t
    }
}, spine.EventData = function(t) {
    this.name = t
}, spine.EventData.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.Event = function(t, e) {
    this.time = t, this.data = e
}, spine.Event.prototype = {
    intValue: 0,
    floatValue: 0,
    stringValue: null
}, spine.AttachmentType = {
    region: 0,
    boundingbox: 1,
    mesh: 2,
    weightedmesh: 3,
    linkedmesh: 4,
    weightedlinkedmesh: 5
}, spine.RegionAttachment = function(t) {
    this.name = t, this.offset = new spine.Float32Array(8), this.offset.length = 8, this.uvs = new spine.Float32Array(8), this.uvs.length = 8
}, spine.RegionAttachment.prototype = {
    type: spine.AttachmentType.region,
    x: 0,
    y: 0,
    rotation: 0,
    scaleX: 1,
    scaleY: 1,
    width: 0,
    height: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    rendererObject: null,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    setUVs: function(t, e, i, r, a) {
        var n = this.uvs;
        a ? (n[2] = t, n[3] = r, n[4] = t, n[5] = e, n[6] = i, n[7] = e, n[0] = i, n[1] = r) : (n[0] = t, n[1] = r, n[2] = t, n[3] = e, n[4] = i, n[5] = e, n[6] = i, n[7] = r)
    },
    updateOffset: function() {
        var t = this.width / this.regionOriginalWidth * this.scaleX,
            e = this.height / this.regionOriginalHeight * this.scaleY,
            i = -this.width / 2 * this.scaleX + this.regionOffsetX * t,
            r = -this.height / 2 * this.scaleY + this.regionOffsetY * e,
            a = i + this.regionWidth * t,
            n = r + this.regionHeight * e,
            s = this.rotation * spine.degRad,
            o = Math.cos(s),
            h = Math.sin(s),
            l = i * o + this.x,
            c = i * h,
            p = r * o + this.y,
            m = r * h,
            u = a * o + this.x,
            d = a * h,
            f = n * o + this.y,
            g = n * h,
            v = this.offset;
        v[0] = l - m, v[1] = p + c, v[2] = l - g, v[3] = f + c, v[4] = u - g, v[5] = f + d, v[6] = u - m, v[7] = p + d
    },
    computeVertices: function(t, e, i, r) {
        t += i.worldX, e += i.worldY;
        var a = i.a,
            n = i.b,
            s = i.c,
            o = i.d,
            h = this.offset;
        r[0] = h[0] * a + h[1] * n + t, r[1] = h[0] * s + h[1] * o + e, r[2] = h[2] * a + h[3] * n + t, r[3] = h[2] * s + h[3] * o + e, r[4] = h[4] * a + h[5] * n + t, r[5] = h[4] * s + h[5] * o + e, r[6] = h[6] * a + h[7] * n + t, r[7] = h[6] * s + h[7] * o + e
    }
}, spine.MeshAttachment = function(t) {
    this.name = t
}, spine.MeshAttachment.prototype = {
    type: spine.AttachmentType.mesh,
    vertices: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function() {
        var t = this.regionU2 - this.regionU,
            e = this.regionV2 - this.regionV,
            i = this.regionUVs.length;
        if (this.uvs && this.uvs.length == i || (this.uvs = new spine.Float32Array(i)), this.regionRotate)
            for (var r = 0; r < i; r += 2) this.uvs[r] = this.regionU + this.regionUVs[r + 1] * t, this.uvs[r + 1] = this.regionV + e - this.regionUVs[r] * e;
        else
            for (r = 0; r < i; r += 2) this.uvs[r] = this.regionU + this.regionUVs[r] * t, this.uvs[r + 1] = this.regionV + this.regionUVs[r + 1] * e
    },
    computeWorldVertices: function(t, e, i, r) {
        var a = i.bone;
        t += a.worldX, e += a.worldY;
        var n = a.a,
            s = a.b,
            o = a.c,
            h = a.d,
            l = this.vertices,
            c = l.length;
        i.attachmentVertices.length == c && (l = i.attachmentVertices);
        for (var p = 0; p < c; p += 2) {
            var m = l[p],
                u = l[p + 1];
            r[p] = m * n + u * s + t, r[p + 1] = m * o + u * h + e
        }
    },
    setParentMesh: function(t) {
        this.parentMesh = t, t && (this.vertices = t.vertices, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
    }
}, spine.WeightedMeshAttachment = function(t) {
    this.name = t
}, spine.WeightedMeshAttachment.prototype = {
    type: spine.AttachmentType.weightedmesh,
    bones: null,
    weights: null,
    uvs: null,
    regionUVs: null,
    triangles: null,
    hullLength: 0,
    r: 1,
    g: 1,
    b: 1,
    a: 1,
    path: null,
    inheritFFD: !0,
    parentMesh: null,
    rendererObject: null,
    regionU: 0,
    regionV: 0,
    regionU2: 0,
    regionV2: 0,
    regionRotate: !1,
    regionOffsetX: 0,
    regionOffsetY: 0,
    regionWidth: 0,
    regionHeight: 0,
    regionOriginalWidth: 0,
    regionOriginalHeight: 0,
    edges: null,
    width: 0,
    height: 0,
    updateUVs: function(t, e, i, r, a) {
        var n = this.regionU2 - this.regionU,
            s = this.regionV2 - this.regionV,
            o = this.regionUVs.length;
        if (this.uvs && this.uvs.length == o || (this.uvs = new spine.Float32Array(o)), this.regionRotate)
            for (var h = 0; h < o; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h + 1] * n, this.uvs[h + 1] = this.regionV + s - this.regionUVs[h] * s;
        else
            for (h = 0; h < o; h += 2) this.uvs[h] = this.regionU + this.regionUVs[h] * n, this.uvs[h + 1] = this.regionV + this.regionUVs[h + 1] * s
    },
    computeWorldVertices: function(t, e, i, r) {
        var a, n, s, o, h, l, c, p = i.bone.skeleton.bones,
            m = this.weights,
            u = this.bones,
            d = 0,
            f = 0,
            g = 0,
            v = 0,
            y = u.length;
        if (i.attachmentVertices.length)
            for (var P = i.attachmentVertices; f < y; d += 2) {
                for (n = 0, s = 0, a = u[f++] + f; f < a; f++, g += 3, v += 2) o = p[u[f]], h = m[g] + P[v], l = m[g + 1] + P[v + 1], c = m[g + 2], n += (h * o.a + l * o.b + o.worldX) * c, s += (h * o.c + l * o.d + o.worldY) * c;
                r[d] = n + t, r[d + 1] = s + e
            } else
                for (; f < y; d += 2) {
                    for (n = 0, s = 0, a = u[f++] + f; f < a; f++, g += 3) o = p[u[f]], h = m[g], l = m[g + 1], c = m[g + 2], n += (h * o.a + l * o.b + o.worldX) * c, s += (h * o.c + l * o.d + o.worldY) * c;
                    r[d] = n + t, r[d + 1] = s + e
                }
    },
    setParentMesh: function(t) {
        this.parentMesh = t, t && (this.bones = t.bones, this.weights = t.weights, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.edges = t.edges, this.width = t.width, this.height = t.height)
    }
}, spine.BoundingBoxAttachment = function(t) {
    this.name = t, this.vertices = new spine.Float32Array
}, spine.BoundingBoxAttachment.prototype = {
    type: spine.AttachmentType.boundingbox,
    computeWorldVertices: function(t, e, i, r) {
        t += i.worldX, e += i.worldY;
        for (var a = i.a, n = i.b, s = i.c, o = i.d, h = this.vertices, l = 0, c = h.length; l < c; l += 2) {
            var p = h[l],
                m = h[l + 1];
            r[l] = p * a + m * n + t, r[l + 1] = p * s + m * o + e
        }
    }
}, spine.AnimationStateData = function(t) {
    this.skeletonData = t, this.animationToMixTime = {}
}, spine.AnimationStateData.prototype = {
    defaultMix: 0,
    setMixByName: function(t, e, i) {
        var r = this.skeletonData.findAnimation(t);
        if (!r) throw "Animation not found: " + t;
        var a = this.skeletonData.findAnimation(e);
        if (!a) throw "Animation not found: " + e;
        this.setMix(r, a, i)
    },
    setMix: function(t, e, i) {
        this.animationToMixTime[t.name + ":" + e.name] = i
    },
    getMix: function(t, e) {
        var i = t.name + ":" + e.name;
        return this.animationToMixTime.hasOwnProperty(i) ? this.animationToMixTime[i] : this.defaultMix
    }
}, spine.TrackEntry = function() {}, spine.TrackEntry.prototype = {
    next: null,
    previous: null,
    animation: null,
    loop: !1,
    delay: 0,
    time: 0,
    lastTime: -1,
    endTime: 0,
    timeScale: 1,
    mixTime: 0,
    mixDuration: 0,
    mix: 1,
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null
}, spine.AnimationState = function(t) {
    this.data = t, this.tracks = [], this.events = []
}, spine.AnimationState.prototype = {
    onStart: null,
    onEnd: null,
    onComplete: null,
    onEvent: null,
    timeScale: 1,
    update: function(t) {
        t *= this.timeScale;
        for (var e = 0; e < this.tracks.length; e++) {
            var i = this.tracks[e];
            if (i) {
                if (i.time += t * i.timeScale, i.previous) {
                    var r = t * i.previous.timeScale;
                    i.previous.time += r, i.mixTime += r
                }
                var a = i.next;
                a ? (a.time = i.lastTime - a.delay, a.time >= 0 && this.setCurrent(e, a)) : !i.loop && i.lastTime >= i.endTime && this.clearTrack(e)
            }
        }
    },
    apply: function(t) {
        for (var e = 0; e < this.tracks.length; e++) {
            var i = this.tracks[e];
            if (i) {
                this.events.length = 0;
                var r = i.time,
                    a = i.lastTime,
                    n = i.endTime,
                    s = i.loop;
                !s && r > n && (r = n);
                var o = i.previous;
                if (o) {
                    var h = o.time;
                    !o.loop && h > o.endTime && (h = o.endTime), o.animation.apply(t, h, h, o.loop, null);
                    var l = i.mixTime / i.mixDuration * i.mix;
                    l >= 1 && (l = 1, i.previous = null), i.animation.mix(t, i.lastTime, r, s, this.events, l)
                } else 1 == i.mix ? i.animation.apply(t, i.lastTime, r, s, this.events) : i.animation.mix(t, i.lastTime, r, s, this.events, i.mix);
                for (var c = 0, p = this.events.length; c < p; c++) {
                    var m = this.events[c];
                    i.onEvent && i.onEvent(e, m), this.onEvent && this.onEvent(e, m)
                }
                if (s ? a % n > r % n : a < n && r >= n) {
                    var u = Math.floor(r / n);
                    i.onComplete && i.onComplete(e, u), this.onComplete && this.onComplete(e, u)
                }
                i.lastTime = i.time
            }
        }
    },
    clearTracks: function() {
        for (var t = 0, e = this.tracks.length; t < e; t++) this.clearTrack(t);
        this.tracks.length = 0
    },
    clearTrack: function(t) {
        if (!(t >= this.tracks.length)) {
            var e = this.tracks[t];
            e && (e.onEnd && e.onEnd(t), this.onEnd && this.onEnd(t), this.tracks[t] = null)
        }
    },
    _expandToIndex: function(t) {
        if (t < this.tracks.length) return this.tracks[t];
        for (; t >= this.tracks.length;) this.tracks[this.tracks.length] = null;
        return null
    },
    setCurrent: function(t, e) {
        var i = this._expandToIndex(t);
        if (i) {
            var r = i.previous;
            i.previous = null, i.onEnd && i.onEnd(t), this.onEnd && this.onEnd(t), e.mixDuration = this.data.getMix(i.animation, e.animation), e.mixDuration > 0 && (e.mixTime = 0, r && i.mixTime / i.mixDuration < .5 ? e.previous = r : e.previous = i)
        }
        this.tracks[t] = e, e.onStart && e.onStart(t), this.onStart && this.onStart(t)
    },
    setAnimationByName: function(t, e, i) {
        var r = this.data.skeletonData.findAnimation(e);
        if (!r) throw "Animation not found: " + e;
        return this.setAnimation(t, r, i)
    },
    setAnimation: function(t, e, i) {
        var r = new spine.TrackEntry;
        return r.animation = e, r.loop = i, r.endTime = e.duration, this.setCurrent(t, r), r
    },
    addAnimationByName: function(t, e, i, r) {
        var a = this.data.skeletonData.findAnimation(e);
        if (!a) throw "Animation not found: " + e;
        return this.addAnimation(t, a, i, r)
    },
    addAnimation: function(t, e, i, r) {
        var a = new spine.TrackEntry;
        a.animation = e, a.loop = i, a.endTime = e.duration;
        var n = this._expandToIndex(t);
        if (n) {
            for (; n.next;) n = n.next;
            n.next = a
        } else this.tracks[t] = a;
        return r <= 0 && (n ? r += n.endTime - this.data.getMix(n.animation, e) : r = 0), a.delay = r, a
    },
    getCurrent: function(t) {
        return t >= this.tracks.length ? null : this.tracks[t]
    }
}, spine.SkeletonJson = function(t) {
    this.attachmentLoader = t, this.linkedMeshes = []
}, spine.SkeletonJson.prototype = {
    scale: 1,
    readSkeletonData: function(t, e) {
        var i = new spine.SkeletonData;
        i.name = e;
        var r = t.skeleton;
        r && (i.hash = r.hash, i.version = r.spine, i.width = r.width || 0, i.height = r.height || 0);
        for (var a = 0, n = (l = t.bones).length; a < n; a++) {
            var s = l[a],
                o = null;
            if (s.parent && !(o = i.findBone(s.parent))) throw "Parent bone not found: " + s.parent;
            (P = new spine.BoneData(s.name, o)).length = (s.length || 0) * this.scale, P.x = (s.x || 0) * this.scale, P.y = (s.y || 0) * this.scale, P.rotation = s.rotation || 0, P.scaleX = s.hasOwnProperty("scaleX") ? s.scaleX : 1, P.scaleY = s.hasOwnProperty("scaleY") ? s.scaleY : 1, P.inheritScale = !s.hasOwnProperty("inheritScale") || s.inheritScale, P.inheritRotation = !s.hasOwnProperty("inheritRotation") || s.inheritRotation, i.bones[a] = P
        }
        var h = t.ik;
        if (h)
            for (a = 0, n = h.length; a < n; a++) {
                for (var l, c = h[a], p = new spine.IkConstraintData(c.name), m = 0, u = (l = c.bones).length; m < u; m++) {
                    var d = i.findBone(l[m]);
                    if (!d) throw "IK bone not found: " + l[m];
                    p.bones[m] = d
                }
                if (p.target = i.findBone(c.target), !p.target) throw "Target bone not found: " + c.target;
                p.bendDirection = !c.hasOwnProperty("bendPositive") || c.bendPositive ? 1 : -1, p.mix = c.hasOwnProperty("mix") ? c.mix : 1, i.ikConstraints[a] = p
            }
        var f = t.transform;
        if (f)
            for (a = 0, n = f.length; a < n; a++) {
                var g = f[a],
                    v = new spine.TransformConstraintData(g.name);
                if (v.bone = i.findBone(g.bone), !v.bone) throw "Bone not found: " + g.bone;
                if (v.target = i.findBone(g.target), !v.target) throw "Target bone not found: " + g.target;
                v.mix = g.hasOwnProperty("translateMix") ? c.translateMix : 1, v.x = (g.x || 0) * this.scale, v.y = (g.y || 0) * this.scale, i.transformConstraints[a] = v
            }
        var y = t.slots;
        for (a = 0, n = y.length; a < n; a++) {
            var P, S = y[a];
            if (!(P = i.findBone(S.bone))) throw "Slot bone not found: " + S.bone;
            var x = new spine.SlotData(S.name, P),
                b = S.color;
            b && (x.r = this.toColor(b, 0), x.g = this.toColor(b, 1), x.b = this.toColor(b, 2), x.a = this.toColor(b, 3)), x.attachmentName = S.attachment, x.blendMode = spine.BlendMode[S.blend || "normal"], i.slots[a] = x
        }
        var w = t.skins;
        for (var A in w)
            if (w.hasOwnProperty(A)) {
                var T = w[A],
                    M = new spine.Skin(A);
                for (var k in T)
                    if (T.hasOwnProperty(k)) {
                        var C = i.findSlotIndex(k),
                            O = T[k];
                        for (var R in O)
                            if (O.hasOwnProperty(R)) {
                                var I = this.readAttachment(M, C, R, O[R]);
                                I && M.addAttachment(C, R, I)
                            }
                    } i.skins[i.skins.length] = M, "default" == M.name && (i.defaultSkin = M)
            } for (a = 0, n = this.linkedMeshes.length; a < n; a++) {
            var E = this.linkedMeshes[a];
            if (!(M = E.skin ? i.findSkin(E.skin) : i.defaultSkin)) throw "Skin not found: " + E.skin;
            if (!(o = M.getAttachment(E.slotIndex, E.parent))) throw "Parent mesh not found: " + E.parent;
            E.mesh.setParentMesh(o), E.mesh.updateUVs()
        }
        this.linkedMeshes.length = 0;
        var B = t.events;
        for (var D in B)
            if (B.hasOwnProperty(D)) {
                var V = B[D],
                    _ = new spine.EventData(D);
                _.intValue = V.int || 0, _.floatValue = V.float || 0, _.stringValue = V.string || null, i.events[i.events.length] = _
            } var F = t.animations;
        for (var X in F) F.hasOwnProperty(X) && this.readAnimation(X, F[X], i);
        return i
    },
    readAttachment: function(t, e, i, r) {
        i = r.name || i;
        var a = r.type || "region";
        "skinnedmesh" == a && (a = "weightedmesh"), a = spine.AttachmentType[a];
        var n = r.path || i,
            s = this.scale;
        switch (a) {
            case spine.AttachmentType.region:
                var o = this.attachmentLoader.newRegionAttachment(t, i, n);
                if (!o) return null;
                o.path = n, o.x = (r.x || 0) * s, o.y = (r.y || 0) * s, o.scaleX = r.hasOwnProperty("scaleX") ? r.scaleX : 1, o.scaleY = r.hasOwnProperty("scaleY") ? r.scaleY : 1, o.rotation = r.rotation || 0, o.width = (r.width || 0) * s, o.height = (r.height || 0) * s;
                var h = r.color;
                return h && (o.r = this.toColor(h, 0), o.g = this.toColor(h, 1), o.b = this.toColor(h, 2), o.a = this.toColor(h, 3)), o.updateOffset(), o;
            case spine.AttachmentType.mesh:
            case spine.AttachmentType.linkedmesh:
                return (l = this.attachmentLoader.newMeshAttachment(t, i, n)) ? (l.path = n, (h = r.color) && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (r.width || 0) * s, l.height = (r.height || 0) * s, r.parent ? (l.inheritFFD = !r.hasOwnProperty("ffd") || r.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: l,
                    skin: r.skin,
                    slotIndex: e,
                    parent: r.parent
                }) : (l.vertices = this.getFloatArray(r, "vertices", s), l.triangles = this.getUint32Array(r, "triangles"), l.regionUVs = this.getFloatArray(r, "uvs", 1), l.updateUVs(), l.hullLength = 2 * (r.hull || 0), r.edges && (l.edges = this.getUint16Array(r, "edges"))), l) : null;
            case spine.AttachmentType.weightedmesh:
            case spine.AttachmentType.weightedlinkedmesh:
                var l;
                if (!(l = this.attachmentLoader.newWeightedMeshAttachment(t, i, n))) return null;
                if (l.path = n, (h = r.color) && (l.r = this.toColor(h, 0), l.g = this.toColor(h, 1), l.b = this.toColor(h, 2), l.a = this.toColor(h, 3)), l.width = (r.width || 0) * s, l.height = (r.height || 0) * s, r.parent) l.inheritFFD = !r.hasOwnProperty("ffd") || r.ffd, this.linkedMeshes[this.linkedMeshes.length] = {
                    mesh: l,
                    skin: r.skin,
                    slotIndex: e,
                    parent: r.parent
                };
                else {
                    for (var c = this.getFloatArray(r, "uvs", 1), p = this.getFloatArray(r, "vertices", 1), m = new spine.Float32Array(3 * c.length * 3), u = new spine.Uint32Array(3 * c.length), d = 0, f = 0, g = 0, v = p.length; d < v;) {
                        var y = 0 | p[d++];
                        u[f++] = y;
                        for (var P = d + 4 * y; d < P;) u[f++] = p[d], m[g++] = p[d + 1] * s, m[g++] = p[d + 2] * s, m[g++] = p[d + 3], d += 4
                    }
                    l.bones = u, l.weights = m, l.triangles = this.getUint32Array(r, "triangles"), l.regionUVs = c, l.updateUVs(), l.hullLength = 2 * (r.hull || 0), r.edges && (l.edges = this.getUint16Array(r, "edges"))
                }
                return l;
            case spine.AttachmentType.boundingbox:
                var S = this.attachmentLoader.newBoundingBoxAttachment(t, i);
                for (p = r.vertices, S.vertices = new spine.Float32Array(p.length), d = 0, v = p.length; d < v; d++) S.vertices[d] = p[d] * s;
                return S
        }
        throw "Unknown attachment type: " + a
    },
    readAnimation: function(t, e, i) {
        var r = [],
            a = 0,
            n = e.slots;
        for (var s in n)
            if (n.hasOwnProperty(s)) {
                var o = n[s],
                    h = i.findSlotIndex(s);
                for (var l in o)
                    if (o.hasOwnProperty(l)) {
                        var c = o[l];
                        if ("color" == l) {
                            (F = new spine.ColorTimeline(c.length)).slotIndex = h;
                            for (var p = 0, m = 0, u = c.length; m < u; m++) {
                                var d = (P = c[m]).color,
                                    f = this.toColor(d, 0),
                                    g = this.toColor(d, 1),
                                    v = this.toColor(d, 2),
                                    y = this.toColor(d, 3);
                                F.setFrame(p, P.time, f, g, v, y), this.readCurve(F, p, P), p++
                            }
                            r[r.length] = F, a = Math.max(a, F.frames[5 * F.getFrameCount() - 5])
                        } else {
                            if ("attachment" != l) throw "Invalid timeline type for a slot: " + l + " (" + s + ")";
                            for ((F = new spine.AttachmentTimeline(c.length)).slotIndex = h, p = 0, m = 0, u = c.length; m < u; m++) {
                                var P = c[m];
                                F.setFrame(p++, P.time, P.name)
                            }
                            r[r.length] = F, a = Math.max(a, F.frames[F.getFrameCount() - 1])
                        }
                    }
            } var S = e.bones;
        for (var x in S)
            if (S.hasOwnProperty(x)) {
                var b = i.findBoneIndex(x);
                if (-1 == b) throw "Bone not found: " + x;
                var w = S[x];
                for (var l in w)
                    if (w.hasOwnProperty(l))
                        if (c = w[l], "rotate" == l) {
                            for ((F = new spine.RotateTimeline(c.length)).boneIndex = b, p = 0, m = 0, u = c.length; m < u; m++) P = c[m], F.setFrame(p, P.time, P.angle), this.readCurve(F, p, P), p++;
                            r[r.length] = F, a = Math.max(a, F.frames[2 * F.getFrameCount() - 2])
                        } else {
                            if ("translate" != l && "scale" != l) throw "Invalid timeline type for a bone: " + l + " (" + x + ")";
                            var A = 1;
                            for ("scale" == l ? F = new spine.ScaleTimeline(c.length) : (F = new spine.TranslateTimeline(c.length), A = this.scale), F.boneIndex = b, p = 0, m = 0, u = c.length; m < u; m++) {
                                var T = ((P = c[m]).x || 0) * A,
                                    M = (P.y || 0) * A;
                                F.setFrame(p, P.time, T, M), this.readCurve(F, p, P), p++
                            }
                            r[r.length] = F, a = Math.max(a, F.frames[3 * F.getFrameCount() - 3])
                        }
            } var k = e.ik;
        for (var C in k)
            if (k.hasOwnProperty(C)) {
                var O = i.findIkConstraint(C);
                for (c = k[C], (F = new spine.IkConstraintTimeline(c.length)).ikConstraintIndex = i.ikConstraints.indexOf(O), p = 0, m = 0, u = c.length; m < u; m++) {
                    var R = (P = c[m]).hasOwnProperty("mix") ? P.mix : 1,
                        I = !P.hasOwnProperty("bendPositive") || P.bendPositive ? 1 : -1;
                    F.setFrame(p, P.time, R, I), this.readCurve(F, p, P), p++
                }
                r[r.length] = F, a = Math.max(a, F.frames[3 * F.getFrameCount() - 3])
            } var E = e.ffd;
        for (var B in E) {
            var D = i.findSkin(B);
            for (s in o = E[B]) {
                h = i.findSlotIndex(s);
                var V = o[s];
                for (var _ in V) {
                    c = V[_];
                    var F = new spine.FfdTimeline(c.length),
                        X = D.getAttachment(h, _);
                    if (!X) throw "FFD attachment not found: " + _;
                    F.slotIndex = h, F.attachment = X;
                    var L, Y = X.type == spine.AttachmentType.mesh;
                    for (L = Y ? X.vertices.length : X.weights.length / 3 * 2, p = 0, m = 0, u = c.length; m < u; m++) {
                        if ((P = c[m]).vertices) {
                            var U, N = P.vertices;
                            (U = new spine.Float32Array(L)).length = L;
                            var Z = P.offset || 0,
                                W = N.length;
                            if (1 == this.scale)
                                for (var j = 0; j < W; j++) U[j + Z] = N[j];
                            else
                                for (j = 0; j < W; j++) U[j + Z] = N[j] * this.scale;
                            if (Y) {
                                var G = X.vertices;
                                for (j = 0, W = U.length; j < W; j++) U[j] += G[j]
                            }
                        } else Y ? U = X.vertices : (U = new spine.Float32Array(L)).length = L;
                        F.setFrame(p, P.time, U), this.readCurve(F, p, P), p++
                    }
                    r[r.length] = F, a = Math.max(a, F.frames[F.getFrameCount() - 1])
                }
            }
        }
        var H = e.drawOrder;
        if (H || (H = e.draworder), H) {
            F = new spine.DrawOrderTimeline(H.length);
            var z = i.slots.length;
            for (p = 0, m = 0, u = H.length; m < u; m++) {
                var q = H[m],
                    K = null;
                if (q.offsets) {
                    for ((K = new spine.Uint32Array(z)).length = z, j = z - 1; j >= 0; j--) K[j] = 4294967295;
                    var J = q.offsets,
                        $ = new spine.Uint32Array(z - J.length);
                    $.length = z - J.length;
                    var Q = 0,
                        tt = 0;
                    for (j = 0, W = J.length; j < W; j++) {
                        var et = J[j];
                        if (-1 == (h = i.findSlotIndex(et.slot))) throw "Slot not found: " + et.slot;
                        for (; Q != h;) $[tt++] = Q++;
                        K[Q + et.offset] = Q++
                    }
                    for (; Q < z;) $[tt++] = Q++;
                    for (j = z - 1; j >= 0; j--) 4294967295 == K[j] && (K[j] = $[--tt])
                }
                F.setFrame(p++, q.time, K)
            }
            r[r.length] = F, a = Math.max(a, F.frames[F.getFrameCount() - 1])
        }
        var it = e.events;
        if (it) {
            for (F = new spine.EventTimeline(it.length), p = 0, m = 0, u = it.length; m < u; m++) {
                var rt = it[m],
                    at = i.findEvent(rt.name);
                if (!at) throw "Event not found: " + rt.name;
                var nt = new spine.Event(rt.time, at);
                nt.intValue = rt.hasOwnProperty("int") ? rt.int : at.intValue, nt.floatValue = rt.hasOwnProperty("float") ? rt.float : at.floatValue, nt.stringValue = rt.hasOwnProperty("string") ? rt.string : at.stringValue, F.setFrame(p++, nt)
            }
            r[r.length] = F, a = Math.max(a, F.frames[F.getFrameCount() - 1])
        }
        i.animations[i.animations.length] = new spine.Animation(t, r, a)
    },
    readCurve: function(t, e, i) {
        var r = i.curve;
        r ? "stepped" == r ? t.curves.setStepped(e) : r instanceof Array && t.curves.setCurve(e, r[0], r[1], r[2], r[3]) : t.curves.setLinear(e)
    },
    toColor: function(t, e) {
        if (8 != t.length) throw "Color hexidecimal length must be 8, recieved: " + t;
        return parseInt(t.substring(2 * e, 2 * e + 2), 16) / 255
    },
    getFloatArray: function(t, e, i) {
        var r = t[e],
            a = new spine.Float32Array(r.length),
            n = 0,
            s = r.length;
        if (1 == i)
            for (; n < s; n++) a[n] = r[n];
        else
            for (; n < s; n++) a[n] = r[n] * i;
        return a
    },
    getUint32Array: function(t, e) {
        for (var i = t[e], r = new spine.Uint32Array(i.length), a = 0, n = i.length; a < n; a++) r[a] = 0 | i[a];
        return r
    },
    getUint16Array: function(t, e) {
        for (var i = t[e], r = new spine.Uint16Array(i.length), a = 0, n = i.length; a < n; a++) r[a] = 0 | i[a];
        return r
    }
}, spine.Atlas = function(t, e) {
    this.textureLoader = e, this.pages = [], this.regions = [];
    var i = new spine.AtlasReader(t),
        r = [];
    r.length = 4;
    for (var a = null;;) {
        var n = i.readLine();
        if (null === n) break;
        if ((n = i.trim(n)).length)
            if (a) {
                var s = new spine.AtlasRegion;
                s.name = n, s.page = a, s.rotate = "true" == i.readValue(), i.readTuple(r);
                var o = parseInt(r[0]),
                    h = parseInt(r[1]);
                i.readTuple(r);
                var l = parseInt(r[0]),
                    c = parseInt(r[1]);
                s.u = o / a.width, s.v = h / a.height, s.rotate ? (s.u2 = (o + c) / a.width, s.v2 = (h + l) / a.height) : (s.u2 = (o + l) / a.width, s.v2 = (h + c) / a.height), s.x = o, s.y = h, s.width = Math.abs(l), s.height = Math.abs(c), 4 == i.readTuple(r) && (s.splits = [parseInt(r[0]), parseInt(r[1]), parseInt(r[2]), parseInt(r[3])], 4 == i.readTuple(r) && (s.pads = [parseInt(r[0]), parseInt(r[1]), parseInt(r[2]), parseInt(r[3])], i.readTuple(r))), s.originalWidth = parseInt(r[0]), s.originalHeight = parseInt(r[1]), i.readTuple(r), s.offsetX = parseInt(r[0]), s.offsetY = parseInt(r[1]), s.index = parseInt(i.readValue()), this.regions[this.regions.length] = s
            } else {
                (a = new spine.AtlasPage).name = n, 2 == i.readTuple(r) && (a.width = parseInt(r[0]), a.height = parseInt(r[1]), i.readTuple(r)), a.format = spine.Atlas.Format[r[0]], i.readTuple(r), a.minFilter = spine.Atlas.TextureFilter[r[0]], a.magFilter = spine.Atlas.TextureFilter[r[1]];
                var p = i.readValue();
                a.uWrap = spine.Atlas.TextureWrap.clampToEdge, a.vWrap = spine.Atlas.TextureWrap.clampToEdge, "x" == p ? a.uWrap = spine.Atlas.TextureWrap.repeat : "y" == p ? a.vWrap = spine.Atlas.TextureWrap.repeat : "xy" == p && (a.uWrap = a.vWrap = spine.Atlas.TextureWrap.repeat), e.load(a, n, this), this.pages[this.pages.length] = a
            }
        else a = null
    }
}, spine.Atlas.prototype = {
    findRegion: function(t) {
        for (var e = this.regions, i = 0, r = e.length; i < r; i++)
            if (e[i].name == t) return e[i];
        return null
    },
    dispose: function() {
        for (var t = this.pages, e = 0, i = t.length; e < i; e++) this.textureLoader.unload(t[e].rendererObject)
    },
    updateUVs: function(t) {
        for (var e = this.regions, i = 0, r = e.length; i < r; i++) {
            var a = e[i];
            a.page == t && (a.u = a.x / t.width, a.v = a.y / t.height, a.rotate ? (a.u2 = (a.x + a.height) / t.width, a.v2 = (a.y + a.width) / t.height) : (a.u2 = (a.x + a.width) / t.width, a.v2 = (a.y + a.height) / t.height))
        }
    }
}, spine.Atlas.Format = {
    alpha: 0,
    intensity: 1,
    luminanceAlpha: 2,
    rgb565: 3,
    rgba4444: 4,
    rgb888: 5,
    rgba8888: 6
}, spine.Atlas.TextureFilter = {
    nearest: 0,
    linear: 1,
    mipMap: 2,
    mipMapNearestNearest: 3,
    mipMapLinearNearest: 4,
    mipMapNearestLinear: 5,
    mipMapLinearLinear: 6
}, spine.Atlas.TextureWrap = {
    mirroredRepeat: 0,
    clampToEdge: 1,
    repeat: 2
}, spine.AtlasPage = function() {}, spine.AtlasPage.prototype = {
    name: null,
    format: null,
    minFilter: null,
    magFilter: null,
    uWrap: null,
    vWrap: null,
    rendererObject: null,
    width: 0,
    height: 0
}, spine.AtlasRegion = function() {}, spine.AtlasRegion.prototype = {
    page: null,
    name: null,
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    u: 0,
    v: 0,
    u2: 0,
    v2: 0,
    offsetX: 0,
    offsetY: 0,
    originalWidth: 0,
    originalHeight: 0,
    index: 0,
    rotate: !1,
    splits: null,
    pads: null
}, spine.AtlasReader = function(t) {
    this.lines = t.split(/\r\n|\r|\n/)
}, spine.AtlasReader.prototype = {
    index: 0,
    trim: function(t) {
        return t.replace(/^\s+|\s+$/g, "")
    },
    readLine: function() {
        return this.index >= this.lines.length ? null : this.lines[this.index++]
    },
    readValue: function() {
        var t = this.readLine(),
            e = t.indexOf(":");
        if (-1 == e) throw "Invalid line: " + t;
        return this.trim(t.substring(e + 1))
    },
    readTuple: function(t) {
        var e = this.readLine(),
            i = e.indexOf(":");
        if (-1 == i) throw "Invalid line: " + e;
        for (var r = 0, a = i + 1; r < 3; r++) {
            var n = e.indexOf(",", a);
            if (-1 == n) break;
            t[r] = this.trim(e.substr(a, n - a)), a = n + 1
        }
        return t[r] = this.trim(e.substring(a)), r + 1
    }
}, spine.AtlasAttachmentLoader = function(t) {
    this.atlas = t
}, spine.AtlasAttachmentLoader.prototype = {
    newRegionAttachment: function(t, e, i) {
        var r = this.atlas.findRegion(i);
        if (!r) throw "Region not found in atlas: " + i + " (region attachment: " + e + ")";
        var a = new spine.RegionAttachment(e);
        return a.rendererObject = r, a.setUVs(r.u, r.v, r.u2, r.v2, r.rotate), a.regionOffsetX = r.offsetX, a.regionOffsetY = r.offsetY, a.regionWidth = r.width, a.regionHeight = r.height, a.regionOriginalWidth = r.originalWidth, a.regionOriginalHeight = r.originalHeight, a
    },
    newMeshAttachment: function(t, e, i) {
        var r = this.atlas.findRegion(i);
        if (!r) throw "Region not found in atlas: " + i + " (mesh attachment: " + e + ")";
        var a = new spine.MeshAttachment(e);
        return a.rendererObject = r, a.regionU = r.u, a.regionV = r.v, a.regionU2 = r.u2, a.regionV2 = r.v2, a.regionRotate = r.rotate, a.regionOffsetX = r.offsetX, a.regionOffsetY = r.offsetY, a.regionWidth = r.width, a.regionHeight = r.height, a.regionOriginalWidth = r.originalWidth, a.regionOriginalHeight = r.originalHeight, a
    },
    newWeightedMeshAttachment: function(t, e, i) {
        var r = this.atlas.findRegion(i);
        if (!r) throw "Region not found in atlas: " + i + " (weighted mesh attachment: " + e + ")";
        var a = new spine.WeightedMeshAttachment(e);
        return a.rendererObject = r, a.regionU = r.u, a.regionV = r.v, a.regionU2 = r.u2, a.regionV2 = r.v2, a.regionRotate = r.rotate, a.regionOffsetX = r.offsetX, a.regionOffsetY = r.offsetY, a.regionWidth = r.width, a.regionHeight = r.height, a.regionOriginalWidth = r.originalWidth, a.regionOriginalHeight = r.originalHeight, a
    },
    newBoundingBoxAttachment: function(t, e) {
        return new spine.BoundingBoxAttachment(e)
    }
}, spine.SkeletonBounds = function() {
    this.polygonPool = [], this.polygons = [], this.boundingBoxes = []
}, spine.SkeletonBounds.prototype = {
    minX: 0,
    minY: 0,
    maxX: 0,
    maxY: 0,
    update: function(t, e) {
        var i = t.slots,
            r = i.length,
            a = t.x,
            n = t.y,
            s = this.boundingBoxes,
            o = this.polygonPool,
            h = this.polygons;
        s.length = 0;
        for (var l = 0, c = h.length; l < c; l++) o[o.length] = h[l];
        for (h.length = 0, l = 0; l < r; l++) {
            var p = i[l],
                m = p.attachment;
            if (m.type == spine.AttachmentType.boundingbox) {
                s[s.length] = m;
                var u, d = o.length;
                d > 0 ? (u = o[d - 1], o.splice(d - 1, 1)) : u = new spine.Float32Array, h[h.length] = u, u.length = m.vertices.length, m.computeWorldVertices(a, n, p.bone, u)
            }
        }
        e && this.aabbCompute()
    },
    aabbCompute: function() {
        for (var t = this.polygons, e = Number.MAX_VALUE, i = Number.MAX_VALUE, r = -Number.MAX_VALUE, a = -Number.MAX_VALUE, n = 0, s = t.length; n < s; n++)
            for (var o = t[n], h = 0, l = o.length; h < l; h += 2) {
                var c = o[h],
                    p = o[h + 1];
                e = Math.min(e, c), i = Math.min(i, p), r = Math.max(r, c), a = Math.max(a, p)
            }
        this.minX = e, this.minY = i, this.maxX = r, this.maxY = a
    },
    aabbContainsPoint: function(t, e) {
        return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY
    },
    aabbIntersectsSegment: function(t, e, i, r) {
        var a = this.minX,
            n = this.minY,
            s = this.maxX,
            o = this.maxY;
        if (t <= a && i <= a || e <= n && r <= n || t >= s && i >= s || e >= o && r >= o) return !1;
        var h = (r - e) / (i - t),
            l = h * (a - t) + e;
        if (l > n && l < o) return !0;
        if ((l = h * (s - t) + e) > n && l < o) return !0;
        var c = (n - e) / h + t;
        return c > a && c < s || (c = (o - e) / h + t) > a && c < s
    },
    aabbIntersectsSkeleton: function(t) {
        return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY
    },
    containsPoint: function(t, e) {
        for (var i = this.polygons, r = 0, a = i.length; r < a; r++)
            if (this.polygonContainsPoint(i[r], t, e)) return this.boundingBoxes[r];
        return null
    },
    intersectsSegment: function(t, e, i, r) {
        for (var a = this.polygons, n = 0, s = a.length; n < s; n++)
            if (a[n].intersectsSegment(t, e, i, r)) return this.boundingBoxes[n];
        return null
    },
    polygonContainsPoint: function(t, e, i) {
        for (var r = t.length, a = r - 2, n = !1, s = 0; s < r; s += 2) {
            var o = t[s + 1],
                h = t[a + 1];
            if (o < i && h >= i || h < i && o >= i) {
                var l = t[s];
                l + (i - o) / (h - o) * (t[a] - l) < e && (n = !n)
            }
            a = s
        }
        return n
    },
    polygonIntersectsSegment: function(t, e, i, r, a) {
        for (var n = t.length, s = e - r, o = i - a, h = e * a - i * r, l = t[n - 2], c = t[n - 1], p = 0; p < n; p += 2) {
            var m = t[p],
                u = t[p + 1],
                d = l * u - c * m,
                f = l - m,
                g = c - u,
                v = s * g - o * f,
                y = (h * f - s * d) / v;
            if ((y >= l && y <= m || y >= m && y <= l) && (y >= e && y <= r || y >= r && y <= e)) {
                var P = (h * g - o * d) / v;
                if ((P >= c && P <= u || P >= u && P <= c) && (P >= i && P <= a || P >= a && P <= i)) return !0
            }
            l = m, c = u
        }
        return !1
    },
    getPolygon: function(t) {
        var e = this.boundingBoxes.indexOf(t);
        return -1 == e ? null : this.polygons[e]
    },
    getWidth: function() {
        return this.maxX - this.minX
    },
    getHeight: function() {
        return this.maxY - this.minY
    }
};
var PhaserSpine, __extends = this && this.__extends || function(t, e) {
    function i() {
        this.constructor = t
    }
    for (var r in e) e.hasOwnProperty(r) && (t[r] = e[r]);
    t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
};
! function(t) {
    var e = function(e) {
        function i(t, i) {
            var r = e.call(this, t, i) || this;
            return r.addSpineCache(), r.addSpineFactory(), r.addSpineLoader(), r
        }
        return __extends(i, e), i.prototype.addSpineLoader = function() {
            Phaser.Loader.prototype.spine = function(t, e, i) {
                var r = this,
                    a = t + "Atlas",
                    n = {
                        atlas: a,
                        basePath: "" === e.substring(0, e.lastIndexOf("/")) ? "." : e.substring(0, e.lastIndexOf("/")),
                        variants: void 0
                    };
                void 0 === i ? i = [""] : n.variants = i, i.forEach((function(t) {
                    r.onFileComplete.add((function(e, i) {
                        i === a && new spine.Atlas(r.game.cache.getText(i), {
                            load: function(e, i, a) {
                                r.image(i, n.basePath + "/" + i.substr(0, i.lastIndexOf(".")) + t + ".png")
                            }
                        })
                    })), r.text(a, e.substr(0, e.lastIndexOf(".")) + t + ".atlas")
                })), this.json(t, e), this.game.cache.addSpine(t, n)
            }
        }, i.prototype.addSpineFactory = function() {
            Phaser.GameObjectFactory.prototype.spine = function(e, i, r, a, n) {
                void 0 === n && (n = this.world);
                var s = new t.Spine(this.game, r, a);
                return s.setToSetupPose(), s.position.x = e, s.position.y = i, n.add(s)
            }, Phaser.GameObjectCreator.prototype.spine = function(e, i, r, a, n) {
                return new t.Spine(this.game, r, a)
            }
        }, i.prototype.addSpineCache = function() {
            Phaser.Cache.prototype.spine = {}, Phaser.Cache.prototype.addSpine = function(t, e) {
                this.spine[t] = e
            }, Phaser.Cache.prototype.getSpine = function(t) {
                return this.spine.hasOwnProperty(t), this.spine[t]
            }
        }, i
    }(Phaser.Plugin);
    e.RESOLUTION_REGEXP = /@(.+)x/, t.SpinePlugin = e
}(PhaserSpine || (PhaserSpine = {})), Phaser.Rope.prototype.postUpdate = function() {}, spine.Bone.yDown = !0,
    function(t) {
        var e = function(e) {
            function i(i, r, a) {
                var n = e.call(this, i) || this;
                n.imageScale = 1;
                var s = n.game.cache.getSpine(r);
                void 0 !== a && -1 !== s.variants.indexOf(a) ? n.imageScale = n.getScaleFromVariant(a) : s.variants && s.variants.length >= 1 && (n.imageScale = n.getScaleFromVariant(s.variants[0]));
                var o = new t.SpineTextureLoader(i),
                    h = new spine.Atlas(i.cache.getText(s.atlas), o),
                    l = new spine.AtlasAttachmentLoader(h),
                    c = new spine.SkeletonJson(l);
                if (n.skeletonData = c.readSkeletonData(i.cache.getJSON(r)), !n.skeletonData) throw new Error("Spine data must be preloaded using Loader.spine");
                n.onEvent = new Phaser.Signal, n.onComplete = new Phaser.Signal, n.onEnd = new Phaser.Signal, n.skeleton = new spine.Skeleton(n.skeletonData), n.skeleton.updateWorldTransform(), n.stateData = new spine.AnimationStateData(n.skeletonData), n.state = new spine.AnimationState(n.stateData), n.state.onEvent = n.onEvent.dispatch.bind(n.onEvent), n.state.onComplete = n.onComplete.dispatch.bind(n.onComplete), n.state.onEnd = n.onEnd.dispatch.bind(n.onEnd), n.slotContainers = [];
                for (var p = 0, m = n.skeleton.slots.length; p < m; p++) {
                    var u = n.skeleton.slots[p],
                        d = u.attachment,
                        f = new Phaser.Group(i);
                    if (n.slotContainers.push(f), n.add(f), u.container = f, d instanceof spine.RegionAttachment) {
                        var g = d.rendererObject.name,
                            v = n.createSprite(u, d);
                        u.currentSprite = v, u.currentSpriteName = g, f.add(v)
                    } else {
                        if (!(d instanceof spine.WeightedMeshAttachment)) continue;
                        var y = n.createMesh(u, d);
                        u.currentMesh = y, u.currentMeshName = d.name, f.add(y)
                    }
                }
                return n.autoUpdate = !0, n
            }
            return __extends(i, e), Object.defineProperty(i.prototype, "autoUpdate", {
                get: function() {
                    return this.updateTransform === t.Spine.prototype.autoUpdateTransform
                },
                set: function(e) {
                    this.updateTransform = e ? t.Spine.prototype.autoUpdateTransform : PIXILegacy.DisplayObjectContainer.prototype.updateTransform
                },
                enumerable: !0,
                configurable: !0
            }), i.prototype.getScaleFromVariant = function(e) {
                var i = t.SpinePlugin.RESOLUTION_REGEXP.exec(e);
                return i ? parseFloat(i[1]) : 1
            }, i.prototype.setTint = function(t) {
                this.globalTint = t;
                for (var e = this.skeleton.slots, i = 0; i < e.length; i++) {
                    var r = e[i];
                    r.currentSprite && (r.currentSprite.tint = t)
                }
            }, i.prototype.update = function(t) {
                if (void 0 !== t) {
                    this.state.update(t), this.state.apply(this.skeleton), this.skeleton.updateWorldTransform();
                    for (var e = this.skeleton.drawOrder, i = this.skeleton.slots, r = 0, a = e.length; r < a; r++) this.children[r] = e[r].container;
                    for (r = 0, a = i.length; r < a; r++) {
                        var n = i[r],
                            s = n.attachment,
                            o = this.slotContainers[r];
                        if (s) {
                            var h = s.type;
                            if (h === spine.AttachmentType.region) {
                                if (s.rendererObject && (!n.currentSpriteName || n.currentSpriteName !== s.name)) {
                                    var l = s.rendererObject.name;
                                    if (void 0 !== n.currentSprite && (n.currentSprite.visible = !1), n.sprites = n.sprites || {}, void 0 !== n.sprites[l]) n.sprites[l].visible = !0;
                                    else {
                                        var c = this.createSprite(n, s);
                                        o.add(c)
                                    }
                                    n.currentSprite = n.sprites[l], n.currentSpriteName = l
                                }
                                var p = n.bone;
                                o.position.x = s.x * p.a + s.y * p.b + p.worldX, o.position.y = s.x * p.c + s.y * p.d + p.worldY, o.scale.x = p.getWorldScaleX(), o.scale.y = p.getWorldScaleY(), o.rotation = (p.getWorldRotationX() - s.rotation) * Math.PI / 180, p.getWorldScaleY() < 0 && (o.scale.y = -o.scale.y), p.getWorldScaleX() < 0 && (o.scale.x = -o.scale.x), (p.getWorldScaleY() < 0 || p.getWorldScaleX() < 0) && (o.rotation = -o.rotation), n.currentSprite.blendMode = n.blendMode, this.globalTint || (n.currentSprite.tint = n.currentSprite.tint = parseInt(Phaser.Color.componentToHex(255 * n.r).substring(0, 2) + Phaser.Color.componentToHex(255 * n.g).substring(0, 2) + Phaser.Color.componentToHex(255 * n.b).substring(0, 2), 16))
                            } else {
                                if (h !== spine.AttachmentType.weightedmesh && h !== spine.AttachmentType.weightedlinkedmesh) {
                                    o.visible = !1;
                                    continue
                                }
                                if (!n.currentMeshName || n.currentMeshName !== s.name) {
                                    var m = s.name;
                                    if (void 0 !== n.currentMesh && (n.currentMesh.visible = !1), n.meshes = n.meshes || {}, void 0 !== n.meshes[m]) n.meshes[m].visible = !0;
                                    else {
                                        var u = this.createMesh(n, s);
                                        o.add(u)
                                    }
                                    n.currentMesh = n.meshes[m], n.currentMeshName = m
                                }
                                s.computeWorldVertices(n.bone.skeleton.x, n.bone.skeleton.y, n, n.currentMesh.vertices)
                            }
                            o.visible = !0, o.alpha = n.a
                        } else o.visible = !1
                    }
                }
            }, i.prototype.destroy = function(t, i) {
                e.prototype.destroy.call(this, !0, i)
            }, i.prototype.autoUpdateTransform = function() {
                if (i.globalAutoUpdate) {
                    this.lastTime = this.lastTime || Date.now();
                    var t = .001 * (Date.now() - this.lastTime);
                    this.lastTime = Date.now(), this.update(t)
                } else this.lastTime = 0;
                PIXILegacy.DisplayObjectContainer.prototype.updateTransform.call(this)
            }, i.prototype.createSprite = function(t, e) {
                var i = e.rendererObject,
                    r = i.page.rendererObject,
                    a = new PIXILegacy.Rectangle(i.x, i.y, i.rotate ? i.height : i.width, i.rotate ? i.width : i.height),
                    n = new PIXILegacy.Texture(r, a),
                    s = new Phaser.Sprite(this.game, 0, 0, n),
                    o = i.rotate ? .5 * Math.PI : 0;
                if (s.scale.x = i.width / i.originalWidth * e.scaleX / this.imageScale, s.scale.y = i.height / i.originalHeight * e.scaleY / this.imageScale, s.rotation = o, s.anchor.x = (.5 * i.originalWidth - i.offsetX) / i.width, s.anchor.y = 1 - (.5 * i.originalHeight - i.offsetY) / i.height, s.alpha = e.a, i.rotate) {
                    var h = s.scale.x;
                    s.scale.x = s.scale.y, s.scale.y = h
                }
                return t.sprites = t.sprites || {}, t.sprites[i.name] = s, s
            }, i.prototype.createMesh = function(t, e) {
                var i = e.rendererObject.page.rendererObject,
                    r = new PIXILegacy.Texture(i),
                    a = new Phaser.Rope(this.game, 0, 0, r);
                return a.drawMode = 1, a.canvasPadding = 1.5, a.vertices = new spine.Float32Array(e.uvs.length), a.uvs = e.uvs, a.indices = e.triangles, a.alpha = e.a, t.meshes = t.meshes || {}, t.meshes[e.name] = a, a
            }, i.prototype.setMixByName = function(t, e, i) {
                this.stateData.setMixByName(t, e, i)
            }, i.prototype.setAnimationByName = function(t, e, i) {
                void 0 === i && (i = !1);
                var r = this.state.data.skeletonData.findAnimation(e);
                return r ? this.state.setAnimation(t, r, i) : null
            }, i.prototype.addAnimationByName = function(t, e, i, r) {
                void 0 === i && (i = !1), void 0 === r && (r = 0);
                var a = this.state.data.skeletonData.findAnimation(e);
                return a ? this.state.addAnimation(t, a, i, r) : null
            }, i.prototype.getCurrentAnimationForTrack = function(t) {
                return this.state.tracks[t] && this.state.tracks[t].animation ? this.state.tracks[t].animation.name : ""
            }, i.prototype.setSkinByName = function(t) {
                var e = this.skeleton.data.findSkin(t);
                e && this.skeleton.setSkin(e)
            }, i.prototype.setSkin = function(t) {
                this.skeleton.setSkin(t)
            }, i.prototype.setToSetupPose = function() {
                this.skeleton.setToSetupPose()
            }, i.prototype.createCombinedSkin = function(t) {
                for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
                if (0 !== e.length) {
                    for (var r = new spine.Skin(t), a = 0; a < e.length; a++) {
                        var n = e[a],
                            s = this.skeleton.data.findSkin(n);
                        if (!s) return;
                        for (var o in s.attachments) {
                            var h = o.split(":"),
                                l = h[0],
                                c = h[1],
                                p = s.attachments[o];
                            if (void 0 === l || void 0 === c) return;
                            void 0 === r.getAttachment(l, c) && r.addAttachment(l, c, p)
                        }
                    }
                    return this.skeleton.data.skins.push(r), r
                }
            }, i
        }(Phaser.Group);
        e.globalAutoUpdate = !0, t.Spine = e
    }(PhaserSpine || (PhaserSpine = {})),
    function(t) {
        var e = function(t) {
            this.load = function(t, e, i) {
                var r = this.game.make.image(0, 0, e);
                t.rendererObject = r.texture.baseTexture
            }, this.unload = function(t) {
                t.destroy()
            }, this.game = t
        };
        (PhaserSpine || (PhaserSpine = {})).SpineTextureLoader = e
    }(), Phaser.ParticleStorm = function(t, e) {
        Phaser.Plugin.call(this, t, e), this.emitters = [], this.dataList = {};
        var i = PIXILegacy.canUseNewCanvasBlendModes();
        this.blendModeMap = {
            NORMAL: [0, "source-over"],
            ADD: [1, "lighter"],
            MULTIPLY: [2, i ? "multiply" : "source-over"],
            SCREEN: [3, i ? "screen" : "source-over"],
            OVERLAY: [4, i ? "overlay" : "source-over"],
            DARKEN: [5, i ? "darken" : "source-over"],
            LIGHTEN: [6, i ? "lighten" : "source-over"],
            COLOR_DODGE: [7, i ? "color-dodge" : "source-over"],
            COLOR_BURN: [8, i ? "color-burn" : "source-over"],
            HARD_LIGHT: [9, i ? "hard-light" : "source-over"],
            SOFT_LIGHT: [10, i ? "soft-light" : "source-over"],
            DIFFERENCE: [11, i ? "difference" : "source-over"],
            EXCLUSION: [12, i ? "exclusion" : "source-over"],
            HUE: [13, i ? "hue" : "source-over"],
            SATURATION: [14, i ? "saturation" : "source-over"],
            COLOR: [15, i ? "color" : "source-over"],
            LUMINOSITY: [16, i ? "luminosity" : "source-over"]
        }, this.hsv = Phaser.Color.HSVColorWheel()
    }, Phaser.ParticleStorm.prototype = Object.create(Phaser.Plugin.prototype), Phaser.ParticleStorm.prototype.constructor = Phaser.ParticleStorm, Phaser.ParticleStorm.SPRITE = "sprite", Phaser.ParticleStorm.PIXEL = "pixel", Phaser.ParticleStorm.RENDERTEXTURE = "render texture", Phaser.ParticleStorm.SPRITE_BATCH = "sprite batch", Phaser.ParticleStorm.BITMAP_DATA = "bitmap data", Phaser.ParticleStorm.BASE = {
        value: 0,
        initial: 0,
        delta: 0,
        offset: 0,
        control: null,
        calc: 0
    }, Phaser.ParticleStorm.BASE_1 = {
        value: 1,
        initial: 0,
        delta: 0,
        offset: 0,
        control: null,
        calc: 1
    }, Phaser.ParticleStorm.BASE_255 = {
        value: 0,
        initial: 0,
        delta: 0,
        offset: 0,
        min: 0,
        max: 255,
        control: null,
        calc: 0
    }, Phaser.ParticleStorm.BASE_359 = {
        value: 0,
        initial: 0,
        delta: 0,
        offset: 0,
        min: 0,
        max: 359,
        control: null,
        calc: 0
    }, Phaser.ParticleStorm.BASE_NULL = {
        value: null,
        initial: 0,
        delta: 0,
        offset: 0,
        control: null,
        calc: 0
    }, Phaser.ParticleStorm.BASE_EMIT = {
        name: null,
        value: 0,
        initial: 0,
        control: null,
        at: null,
        inherit: !0,
        offsetX: 0,
        offsetY: 0
    }, Phaser.ParticleStorm.Controls = {}, Phaser.ParticleStorm.Zones = {}, Phaser.ParticleStorm.prototype.createEmitter = function(t, e, i) {
        var r = new Phaser.ParticleStorm.Emitter(this, t, e, i);
        return this.emitters.push(r), r
    }, Phaser.ParticleStorm.prototype.removeEmitter = function(t) {
        for (var e = 0; e < this.emitters.length; e++)
            if (this.emitters[e] === t) return void this.emitters.splice(e, 1)
    }, Phaser.ParticleStorm.prototype.addData = function(t, e) {
        if (void 0 === t) return this;
        if (Array.isArray(t))
            for (var i = 0; i < t.length; i++) this.dataList[t[i]] = this.game.cache.getJSON(t[i]);
        else this.dataList[t] = void 0 !== e ? e : this.game.cache.getJSON(t);
        return this
    }, Phaser.ParticleStorm.prototype.getData = function(t) {
        return this.dataList[t]
    }, Phaser.ParticleStorm.prototype.clearData = function(t) {
        if (void 0 === t) this.dataList = {};
        else if (Array.isArray(t))
            for (var e = 0; e < t.length; e++) delete this.dataList[t[e]];
        else delete this.dataList[t];
        return this
    }, Phaser.ParticleStorm.prototype.cloneData = function(t, e) {
        if (void 0 === t) return this;
        if (Array.isArray(t))
            for (var i = 0; i < t.length; i++) this.dataList[t[i]] = Phaser.Utils.extend(!0, this.game.cache.getJSON(t[i]));
        else this.dataList[t] = void 0 !== e ? Phaser.Utils.extend(!0, e) : Phaser.Utils.extend(!0, this.game.cache.getJSON(t));
        return this
    }, Phaser.ParticleStorm.prototype.createPointZone = function(t, e) {
        return new Phaser.ParticleStorm.Zones.Point(this.game, t, e)
    }, Phaser.ParticleStorm.prototype.createLineZone = function(t, e, i, r) {
        return new Phaser.ParticleStorm.Zones.Line(this.game, t, e, i, r)
    }, Phaser.ParticleStorm.prototype.createRectangleZone = function(t, e) {
        return new Phaser.ParticleStorm.Zones.Rectangle(this.game, t, e)
    }, Phaser.ParticleStorm.prototype.createCircleZone = function(t) {
        return new Phaser.ParticleStorm.Zones.Circle(this.game, t)
    }, Phaser.ParticleStorm.prototype.createEllipseZone = function(t, e) {
        return new Phaser.ParticleStorm.Zones.Ellipse(this.game, t, e)
    }, Phaser.ParticleStorm.prototype.createLinearSplineZone = function(t, e, i) {
        return new Phaser.ParticleStorm.Zones.Spline(this.game, 0, t, e, i)
    }, Phaser.ParticleStorm.prototype.createBezierSplineZone = function(t, e, i) {
        return new Phaser.ParticleStorm.Zones.Spline(this.game, 1, t, e, i)
    }, Phaser.ParticleStorm.prototype.createCatmullSplineZone = function(t, e, i) {
        return new Phaser.ParticleStorm.Zones.Spline(this.game, 2, t, e, i)
    }, Phaser.ParticleStorm.prototype.createSplineZone = function(t, e, i, r) {
        return new Phaser.ParticleStorm.Zones.Spline(this.game, t, e, i, r)
    }, Phaser.ParticleStorm.prototype.createTextZone = function(t) {
        return new Phaser.ParticleStorm.Zones.Text(this.game, t)
    }, Phaser.ParticleStorm.prototype.createImageZone = function(t) {
        return new Phaser.ParticleStorm.Zones.Image(this.game, t)
    }, Phaser.ParticleStorm.prototype.update = function() {
        if (this.active)
            for (var t = 0; t < this.emitters.length; t++) this.emitters[t].manualUpdate || this.emitters[t].update()
    }, Phaser.ParticleStorm.Emitter = function(t, e, i, r) {
        this.game = t.game, this.parent = t, this.renderer = null, this.renderType = null, this.graph = Phaser.ParticleStorm.Graph, this.enabled = !1, this.manualUpdate = !1, this.scrollSpeed = new Phaser.Point, this.force = new Phaser.Point, this.onEmit = null, this.onComplete = null, this.onKill = null, this.particleClass = Phaser.ParticleStorm.Particle, this.timer = this.game.time.create(!1), this.timerEvent = null, this.list = [], this.pool = [], this.batch = [], this.wells = [], this._rnd = new Phaser.Point, this._step = new Phaser.Point, this._pCount = 0, this._delay = {
            enabled: !1,
            start: 0,
            inc: 0,
            visible: !1
        }, this.emitterScale = new Phaser.Point(1, 1), this.init(e, i, r)
    }, Phaser.ParticleStorm.Emitter.prototype = {
        init: function(t, e, i) {
            void 0 === t && (t = Phaser.ParticleStorm.SPRITE);
            var r = this.game.width,
                a = this.game.height;
            switch (t) {
                case Phaser.ParticleStorm.SPRITE:
                    this.renderer = new Phaser.ParticleStorm.Renderer.Sprite(this);
                    break;
                case Phaser.ParticleStorm.PIXEL:
                    this.renderer = new Phaser.ParticleStorm.Renderer.Pixel(this, r, a);
                    break;
                case Phaser.ParticleStorm.RENDERTEXTURE:
                    this.renderer = new Phaser.ParticleStorm.Renderer.RenderTexture(this, r, a);
                    break;
                case Phaser.ParticleStorm.SPRITE_BATCH:
                    this.renderer = new Phaser.ParticleStorm.Renderer.SpriteBatch(this);
                    break;
                case Phaser.ParticleStorm.BITMAP_DATA:
                    this.renderer = new Phaser.ParticleStorm.Renderer.BitmapData(this, r, a);
                    break;
                default:
                    return console.warn("ParticleManager.init - Invalid renderType given"), !1
            }
            this.renderType = t, e && this.force.set(e.x, e.y), i && this.scrollSpeed.set(i.x, i.y), this.list = [], this.pool = [], this.wells = [], this.enabled = !0
        },
        addToWorld: function(t) {
            return void 0 === t && (t = this.game.world), this.renderer.addToWorld(t)
        },
        createGravityWell: function(t, e, i, r, a) {
            var n = new Phaser.ParticleStorm.GravityWell(this, t, e, i, r, a);
            return this.wells.push(n), n
        },
        seed: function(t) {
            for (var e = 0; e < t; e++) {
                var i = new Phaser.ParticleStorm.Particle(this);
                this.pool.push(i)
            }
            return this
        },
        emitDelayed: function(t, e, i, r, a) {
            return !this.enabled || !this.parent.dataList[e] || t <= 0 ? null : (this.timerEvent = this.timer.add(t, this.emit, this, e, i, r, a), this.timer.start(), this.timerEvent)
        },
        emit: function(t, e, i, r) {
            if (!this.enabled || !this.parent.dataList[t]) return null;
            if (this.batch = [], this._pCount = 0, this._step.x = 0, this._step.y = 0, void 0 === e && (e = 0), void 0 === i && (i = 0), !r) return this.emitParticle(t, e, i, null);
            var a = r.hasOwnProperty("total") ? r.total : 1;
            if (r.xStep > 0 ? this._step.x = r.xStep : this._step.x = 0, r.yStep > 0 ? this._step.y = r.yStep : this._step.y = 0, this._delay.enabled = !1, r.delay && (this._delay.enabled = !0, "number" == typeof r.delay ? (this._delay.start = r.delay, this._delay.step = 0, this._delay.visible = !1) : (this._delay.start = r.delay.start ? r.delay.start : 0, this._delay.step = r.delay.step ? r.delay.step : 0, this._delay.visible = !!r.delay.visible)), r.zone)
                if (void 0 === r.random && void 0 === r.full && void 0 === r.percent || r.random) r.zone.emit(this, t, e, i, a, r.setAlpha, r.setColor);
                else if (void 0 !== r.percent || void 0 === r.full && r.random) {
                if (void 0 !== r.percent) {
                    var n = 0;
                    "number" == typeof r.percent ? n = r.percent : r.percent.hasOwnProperty("min") ? n = this.game.rnd.between(r.percent.min, r.percent.max) : r.percent.callback && (n = r.percent.callback.call(r.percent.context, this)), r.zone.emitPercent(this, t, e, i, a, n)
                }
            } else r.zone.emitFull(this, t, e, i, r.step, r.spacing, r.setAlpha, r.setColor);
            else
                for (var s = 0; s < a; s++) this.emitParticle(t, e, i, null);
            if (r.radiate)
                for (var o = 0; o < this.batch.length; o++) this.batch[o].radiate(r.radiate.velocity, r.radiate.from, r.radiate.to);
            else if (r.radiateFrom)
                for (o = 0; o < this.batch.length; o++) this.batch[o].radiateFrom(r.radiateFrom.x, r.radiateFrom.y, r.radiateFrom.velocity);
            var h = r.hasOwnProperty("repeat") ? r.repeat : 0;
            if (0 !== h) {
                var l = r.hasOwnProperty("frequency") ? r.frequency : 250;
                "number" != typeof l && (l = l.min + Math.random() * (l.max - l.min)), delete r.repeat, -1 === h ? this.timerEvent = this.timer.loop(l, this.emit, this, t, e, i, r) : h > 0 && (this.timerEvent = this.timer.repeat(l, h, this.emit, this, t, e, i, r)), this.timer.start()
            }
            return this._pCount = 0, this.batch
        },
        emitParticle: function(t, e, i, r) {
            var a = this.pool.pop();
            return a || (a = new this.particleClass(this)), a.parent = r, Array.isArray(e) && (e = this.game.rnd.between(e[0], e[1])), Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), e += this._step.x * this._pCount, i += this._step.y * this._pCount, a.reset(this.renderer, e, i, this.parent.dataList[t]), a.alive ? (!r && this._delay.enabled && (a.delay += this._delay.start + this._pCount * this._delay.step, a.delayVisible = this._delay.visible), this.list.push(a), this.batch.push(a), r || this._pCount++) : (a.kill(), this.onKill && this.onKill.dispatch(this, a), this.pool.push(a)), a
        },
        update: function() {
            var t = this.game.time.elapsed;
            this.renderer.preUpdate();
            for (var e = this.list.length - 1; e >= 0; e--) {
                var i = this.list[e];
                i.ignoreScrollSpeed || (i.transform.x += this.scrollSpeed.x, i.transform.y += this.scrollSpeed.y);
                for (var r = 0; r < this.wells.length; r++) this.wells[r].active && this.wells[r].step(i);
                i.step(t, this.force) || (i.kill(), this.pool.push(i), this.list.splice(e, 1))
            }
            return this.renderer.postUpdate(), this.list.length
        },
        updateFrequency: function(t, e, i, r) {
            if (t.at) {
                for (var a = 0, n = 0; n < t.at.length; n++) {
                    var s = t.at[n];
                    (s.time > i || 0 === s.time && 0 === i) && s.time <= r && (s.value > 0 && s.value < 1 ? Math.random() < s.value && (a += 1) : a += s.value)
                }
                return a
            }
            return this.graph.getParamArea(t, i, r) * e
        },
        forEach: function(t, e) {
            if (arguments.length <= 2)
                for (var i = 0; i < this.list.length; i++) t.call(e, this.list[i]);
            else {
                var r = [null];
                for (i = 2; i < arguments.length; i++) r.push(arguments[i]);
                for (i = 0; i < this.list.length; i++) r[0] = this.list[i], t.apply(e, r)
            }
        },
        forEachNew: function(t, e) {
            if (0 !== this.batch.length)
                if (arguments.length <= 2)
                    for (var i = 0; i < this.batch.length; i++) t.call(e, this.batch[i]);
                else {
                    var r = [null];
                    for (i = 2; i < arguments.length; i++) r.push(arguments[i]);
                    for (i = 0; i < this.batch.length; i++) r[0] = this.batch[i], t.apply(e, r)
                }
        },
        getParticle: function(t) {
            return void 0 === t && (t = 0), this.list[t] ? this.list[t] : null
        },
        debug: function(t, e) {
            var i = this.game.debug;
            if (i) {
                i.start(t + 4, e + 16, "rgb(255, 255, 255)", 132), i.context.fillStyle = "rgba(0, 74, 128, 0.5)", i.context.fillRect(t, e, 360, 70);
                var r = this.force.x + "",
                    a = this.force.y + "";
                i.line("Force:", r.substr(0, 8), a.substr(0, 8)), i.line("Scroll Speed:", this.scrollSpeed.x, this.scrollSpeed.y), i.line("Alive:", "Dead:", "Total:"), i.line(this.alive, this.dead, this.total), i.stop()
            }
        },
        destroy: function() {
            this.renderer.clear && this.renderer.clear(), this.renderer.destroy(), this.renderer = null;
            for (var t = this.list.length - 1; t >= 0; t--) this.list[t].kill(), this.list.splice(t, 1);
            this.list = [], this.pool = [], this.batch = [], this.wells = []
        }
    }, Object.defineProperty(Phaser.ParticleStorm.Emitter.prototype, "paused", {
        get: function() {
            return !this.enabled
        },
        set: function(t) {
            this.enabled = !t
        }
    }), Object.defineProperty(Phaser.ParticleStorm.Emitter.prototype, "total", {
        get: function() {
            return this.alive + this.dead
        }
    }), Object.defineProperty(Phaser.ParticleStorm.Emitter.prototype, "alive", {
        get: function() {
            return this.list.length
        }
    }), Object.defineProperty(Phaser.ParticleStorm.Emitter.prototype, "dead", {
        get: function() {
            return this.pool.length
        }
    }), Phaser.ParticleStorm.Emitter.prototype.constructor = Phaser.ParticleStorm.Emitter, Phaser.ParticleStorm.Particle = function(t) {
        this.emitter = t, this.renderer = null, this.graph = Phaser.ParticleStorm.Graph, this.transform = new Phaser.ParticleStorm.Controls.Transform(this), this.color = new Phaser.ParticleStorm.Controls.Color(this), this.texture = new Phaser.ParticleStorm.Controls.Texture(this), this.parent = null, this.lifespan = 2e3, this.keepAlive = !1, this.delay = 0, this.delayVisible = !1, this.life = 0, this.sprite = null, this.visible = !1, this.isComplete = !1, this.ignoreForce = !1, this.ignoreScrollSpeed = !1, this.emit = {}, this._age = 0, this._lastPercent = 0, this._numToEmit = 0, this.particleScale = new Phaser.Point(1, 1)
    }, Phaser.ParticleStorm.Particle.prototype = {
        reset: function(t, e, i, r) {
            return this.renderer = t, this.transform.reset(), this.color.reset(), this.texture.reset(), this.emit = Object.create(Phaser.ParticleStorm.BASE_EMIT), this.isComplete = !1, this.keepAlive = !1, this.delay = 0, this.delayVisible = !1, this.ignoreForce = !1, this.ignoreScrollSpeed = !1, this.alive = !1, this.lifespan = 2e3, this.life = 0, this.visible = !1, this._age = 0, this._lastPercent = 0, this._numToEmit = 0, this.particleScale.setTo(this.emitter.emitterScale.x, this.emitter.emitterScale.y), void 0 !== r && this.create(e, i, r), this
        },
        create: function(t, e, i) {
            if (i.hasOwnProperty("lifespan") && (this.lifespan = this.graph.getMinMax(i.lifespan)), this.keepAlive = i.keepAlive, i.hasOwnProperty("delay") && (this.delay = this.graph.getMinMax(i.delay)), this.ignoreForce = i.ignoreForce, this.ignoreScrollSpeed = i.ignoreScrollSpeed, this.transform.init(t, e, i), this.color.init(i), this.texture.init(i), i.emit && (this.emit = Object.create(i.emit)), this.visible = !1 !== i.visible, this.alive = !0, this.parent && this.parent.emit && this.parent.emit.inherit && (this.alive = this.onInherit(this.parent)), this.alive) {
                this.transform.step(), this.color.step();
                var r = this.renderer.add(this);
                r && this.texture.step(i, r), this.onEmit(), this.emitter.onEmit && this.emitter.onEmit.dispatch(this.emitter, this), this.renderer.update(this)
            }
            return this
        },
        step: function(t, e) {
            if (this._age += t, this.delay) {
                if (this._age < this.delay) return this.renderer.update(this), !0;
                this.delay = 0, this._age = 0
            }
            if (this._lastPercent = this.life, this.lifespan > 0 && (this.life = Math.min(this._age / this.lifespan, 1)), e && !this.ignoreForce && (this.transform.velocity.x.value += e.x, this.transform.velocity.y.value += e.y), this.transform.step(), this.color.step(), this.onUpdate(), this.alive) {
                for (this._numToEmit += this.emitter.updateFrequency(this.emit, t, this._lastPercent, this.life); this._numToEmit >= 1;) this.emitChild();
                this.renderer.update(this)
            }
            return this.isComplete || 1 !== this.life || (this.isComplete = !0, this.emitter.onComplete && this.emitter.onComplete.dispatch(this.emitter, this)), this.life < 1 || this.keepAlive
        },
        emitChild: function() {
            var t = 0 | this.graph.getMinMax(this.emit.offsetX),
                e = 0 | this.graph.getMinMax(this.emit.offsetY);
            if (this.emit.rect) {
                var i = this.emit.rect;
                t = Math.random() * i.width + i.x, e = Math.random() * i.height + i.y
            } else if (this.emit.circle) {
                var r = this.emit.circle;
                e = Math.random() * r * 2 - r;
                var a = Math.sqrt(r * r - e * e);
                t = Math.random() * a * 2 - a
            }
            var n = this.emit.name;
            if ("string" != typeof n && (n = this.getChildKey(this.emit.name)), n) {
                var s = this.emitter.emitParticle(n, this.transform.x + t, this.transform.y + e, this);
                s && this.emit.overwrite && this.applyOverwrite(this.emit.overwrite, s)
            }
            this._numToEmit -= 1
        },
        applyOverwrite: function(t, e) {
            return e
        },
        getChildKey: function(t) {
            if (Array.isArray(t)) return this.emitter.game.rnd.pick(t);
            if (void 0 !== t.at && t.at.length > 0) {
                for (var e = t.at[0].value, i = 0; i < t.at.length && !(t.at[i].time > this.life); i++) e = t.at[i].value;
                return e
            }
            return null
        },
        radiate: function(t, e, i) {
            void 0 === i && void 0 !== e ? i = e : (void 0 === e && (e = 0), void 0 === i && (i = 359));
            var r = t;
            t.hasOwnProperty("min") ? r = this.graph.getMinMax(t) : Array.isArray(t) && (r = parseFloat(this.emitter.game.rnd.pick(t), 10));
            var a = (Math.random() * (i - e) + e) * Math.PI / 180;
            return this.transform.velocity.x.value = Math.sin(a) * r, this.transform.velocity.y.value = -Math.cos(a) * r, this
        },
        radiateFrom: function(t, e, i) {
            var r = i;
            i.hasOwnProperty("min") ? r = this.graph.getMinMax(i) : Array.isArray(i) && (r = parseFloat(this.emitter.game.rnd.pick(i), 10));
            var a = this.transform.x - t,
                n = this.transform.y - e,
                s = Math.sqrt(a * a + n * n);
            return this.transform.velocity.x.value = a * r / s, this.transform.velocity.y.value = n * r / s, this
        },
        target: function(t) {
            var e = 0,
                i = 0,
                r = this.transform;
            if (t.x && (e = t.x), t.y && (i = t.y), t.zone) {
                var a = t.zone.getRandom();
                e += a.x, i += a.y
            }
            var n = Math.atan2(i - r.y, e - r.x),
                s = r.x - e,
                o = r.y - i,
                h = Math.sqrt(s * s + o * o) / (this.lifespan / 1e3),
                l = Math.cos(n) * h * r.time.physicsElapsed,
                c = Math.sin(n) * h * r.time.physicsElapsed;
            return t.speed ? (this.graph.fromControl({
                value: 2 * l,
                control: t.speed
            }, r.velocity.x), this.graph.fromControl({
                value: 2 * c,
                control: t.speed
            }, r.velocity.y)) : (r.velocity.x.value = l, r.velocity.y.value = c), this
        },
        setLife: function(t, e) {
            return this.lifespan = this.graph.getMinMax(t), this.life = 0, this._age = 0, this._lastPercent = 0, this.isComplete = !1, this.keepAlive = e, this
        },
        kill: function() {
            this.alive = !1, this.renderer.kill(this), this.onKill()
        },
        onEmit: function() {},
        onUpdate: function() {},
        onInherit: function() {
            return !0
        },
        onKill: function() {}
    }, Object.defineProperty(Phaser.ParticleStorm.Particle.prototype, "lifePercent", {
        get: function() {
            return Math.round(100 * this.life)
        }
    }), Object.defineProperty(Phaser.ParticleStorm.Particle.prototype, "frequency", {
        get: function() {
            return this.emit.value
        },
        set: function(t) {
            this.emit.value = t
        }
    }), Phaser.ParticleStorm.Particle.prototype.constructor = Phaser.ParticleStorm.Particle, Phaser.ParticleStorm.GravityWell = function(t, e, i, r, a, n) {
        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === r && (r = 0), void 0 === a && (a = 100), void 0 === n && (n = 50), this.emitter = t, this.time = t.game.time, this.position = new Phaser.Point(e, i), this.active = !0, this._gravity = n, this._power = 0, this._epsilon = 0, this.power = r, this.epsilon = a
    }, Phaser.ParticleStorm.GravityWell.prototype = {
        step: function(t) {
            var e = this.position.x - t.transform.x,
                i = this.position.y - t.transform.y,
                r = e * e + i * i;
            if (0 !== r) {
                var a = Math.sqrt(r);
                r < this._epsilon && (r = this._epsilon);
                var n = this._power * this.time.elapsed / (r * a);
                t.transform.velocity.x.value += e * n, t.transform.velocity.y.value += i * n
            }
        }
    }, Object.defineProperty(Phaser.ParticleStorm.GravityWell.prototype, "epsilon", {
        get: function() {
            return Math.sqrt(this._epsilon)
        },
        set: function(t) {
            this._epsilon = t * t
        }
    }), Object.defineProperty(Phaser.ParticleStorm.GravityWell.prototype, "power", {
        get: function() {
            return this._power / this.gravity
        },
        set: function(t) {
            this._power = t * this.gravity
        }
    }), Object.defineProperty(Phaser.ParticleStorm.GravityWell.prototype, "gravity", {
        get: function() {
            return this._gravity
        },
        set: function(t) {
            var e = this.power;
            this._gravity = t, this.power = e
        }
    }), Phaser.ParticleStorm.GravityWell.prototype.constructor = Phaser.ParticleStorm.GravityWell, Phaser.ParticleStorm.Graph = {
        CONTROL_LINEAR: [{
            x: 0,
            y: 1
        }, {
            x: 1,
            y: 0
        }],
        CONTROL_REVERSE: [{
            x: 0,
            y: 0
        }, {
            x: 1,
            y: 1
        }],
        CONTROL_YOYO: [{
            x: 0,
            y: 0
        }, {
            x: .5,
            y: 1
        }, {
            x: 1,
            y: 0
        }],
        getControlValue: function(t, e) {
            var i = 0,
                r = t[i];
            if (r.x === e) return r.y;
            for (; r.x <= e;) {
                if (i >= t.length - 1) return r.x;
                r = t[++i]
            }
            var a = t[i - 1];
            return a.y + (e - a.x) * (r.y - a.y) / (r.x - a.x)
        },
        getControlValues: function(t, e, i) {
            var r = [{
                x: e,
                y: Phaser.ParticleStorm.Graph.getControlValue(t, e)
            }];
            if (e >= i) return r;
            for (var a = 0; a < t.length; a++)
                if (t[a].x > e) {
                    if (!(t[a].x < i)) break;
                    r.push(t[a])
                } return r.push({
                x: i,
                y: Phaser.ParticleStorm.Graph.getControlValue(t, i)
            }), r
        },
        getParamArea: function(t, e, i) {
            return t.control ? t.value * Phaser.ParticleStorm.Graph.getControlArea(t.control, e, i) : t.value
        },
        getControlArea: function(t, e, i) {
            var r = Phaser.ParticleStorm.Graph.getControlValues(t, e, i);
            if (e >= i) return r[0].y;
            for (var a = r.length > 1 ? 0 : r.y, n = r[0], s = 1; s < r.length; s++) {
                var o = r[s];
                a += .5 * (o.x - n.x) * (n.y + o.y), n = o
            }
            return a
        },
        getMinMaxInitial: function(t) {
            return void 0 !== t.initial ? Phaser.ParticleStorm.Graph.getMinMax(t.initial) : 0
        },
        isNumeric: function(t) {
            return !isNaN(parseFloat(t)) && isFinite(t)
        },
        getMinMax: function(t) {
            return null != t && void 0 !== t.min && void 0 !== t.max ? t.min + Math.random() * (t.max - t.min) : t
        },
        clone: function(t, e) {
            return e.value = t.value, e.initial = t.initial, e.delta = t.delta, e.offset = t.offset, e.min = t.min, e.max = t.max, e.control = t.control, e
        },
        fromControl: function(t, e) {
            void 0 !== t.value && (e.value = Phaser.ParticleStorm.Graph.getMinMax(t.value)), t.control && ("linear" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_LINEAR : "reverse" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_REVERSE : "yoyo" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_YOYO : e.control = t.control)
        },
        fromData: function(t, e) {
            return null != t && ("number" == typeof t ? (e.value = t, !0) : (void 0 !== t.min ? e.value = Phaser.ParticleStorm.Graph.getMinMax(t) : void 0 !== t.value && (e.value = Phaser.ParticleStorm.Graph.getMinMax(t.value)), void 0 !== t.initial && (e.initial = Phaser.ParticleStorm.Graph.getMinMax(t.initial)), void 0 !== t.delta && (e.delta = Phaser.ParticleStorm.Graph.getMinMax(t.delta)), void 0 !== t.offset && (e.offset = Phaser.ParticleStorm.Graph.getMinMax(t.offset)), t.control && ("linear" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_LINEAR : "reverse" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_REVERSE : "yoyo" === t.control ? e.control = Phaser.ParticleStorm.Graph.CONTROL_YOYO : e.control = t.control), !0))
        },
        getValue: function(t, e) {
            if (!t.control || void 0 === e) return t.value;
            var i = t.control[0];
            if (i.x === e) return i.y;
            var r = t.control.length - 1,
                a = t.control[r];
            if (a.x === e) return a.y;
            for (r = 0; i.x <= e;) {
                if (r >= t.control.length - 1) return i.y;
                i = t.control[++r]
            }
            var n = t.control[r - 1];
            return t.value * (n.y + (e - n.x) * (i.y - n.y) / (i.x - n.x))
        },
        getClampedValue: function(t, e) {
            return Phaser.Math.clamp(Math.floor(t.initial + this.getValue(t, e)), t.min, t.max)
        }
    }, Phaser.ParticleStorm.Zones = {}, Phaser.ParticleStorm.Zones.Base = function(t) {
        this.game = t, this.active = !0, this.scale = new Phaser.Point(1, 1), this.alphaThreshold = 0, this._rnd = new Phaser.Point
    }, Phaser.ParticleStorm.Zones.Base.prototype = {
        getRandom: function() {
            return this.shape === Phaser.Point ? this._rnd = this.shape : this.shape.random(this._rnd), this._rnd.x *= this.scale.x, this._rnd.y *= this.scale.y, this._rnd
        },
        emit: function(t, e, i, r, a) {
            Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
            for (var n = null, s = 0; s < a; s++) this.shape.random(this._rnd), n = t.emitParticle(e, i + this._rnd.x * this.scale.x, r + this._rnd.y * this.scale.y, null);
            return n
        }
    }, Phaser.ParticleStorm.Zones.Base.prototype.constructor = Phaser.ParticleStorm.Zones.Base, Phaser.ParticleStorm.Zones.Point = function(t, e, i) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.shape = new Phaser.Point(e, i)
    }, Phaser.ParticleStorm.Zones.Point.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Point.prototype.constructor = Phaser.ParticleStorm.Zones.Point, Phaser.ParticleStorm.Zones.Rectangle = function(t, e, i) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.shape = new Phaser.Rectangle(0, 0, e, i)
    }, Phaser.ParticleStorm.Zones.Rectangle.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Rectangle.prototype.constructor = Phaser.ParticleStorm.Zones.Rectangle, Phaser.ParticleStorm.Zones.Circle = function(t, e) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.shape = new Phaser.Circle(0, 0, 2 * e)
    }, Phaser.ParticleStorm.Zones.Circle.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Circle.prototype.constructor = Phaser.ParticleStorm.Zones.Circle, Phaser.ParticleStorm.Zones.Ellipse = function(t, e, i) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.shape = new Phaser.Ellipse(0, 0, e, i)
    }, Phaser.ParticleStorm.Zones.Ellipse.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Ellipse.prototype.constructor = Phaser.ParticleStorm.Zones.Ellipse, Phaser.ParticleStorm.Zones.Line = function(t, e, i, r, a) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.shape = new Phaser.Line(e, i, r, a)
    }, Phaser.ParticleStorm.Zones.Line.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Line.prototype.constructor = Phaser.ParticleStorm.Zones.Line, Phaser.ParticleStorm.Zones.Spline = function(t, e, i, r, a) {
        void 0 === e && (e = 0), void 0 === i && (i = 1e3), void 0 === r && (r = !0), Phaser.ParticleStorm.Zones.Base.call(this, t), this.math = this.game.math, this.points = {
            x: [],
            y: []
        }, this.path = [], this.resolution = i, this.mode = e, this.closed = r, this.mult = 0, this.update(a)
    }, Phaser.ParticleStorm.Zones.Spline.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Spline.prototype.constructor = Phaser.ParticleStorm.Zones.Spline, Phaser.ParticleStorm.Zones.Spline.prototype.update = function(t) {
        this.points = {
            x: [],
            y: []
        }, this.path = [];
        for (var e = 0; e < t.length; e++) this.points.x.push(t[e].x), this.points.y.push(t[e].y);
        this.closed && (this.points.x.push(t[0].x), this.points.y.push(t[0].y));
        var i = 0,
            r = 1 / this.resolution;
        for (e = 0; e <= 1; e += r) {
            if (0 === this.mode) var a = this.math.linearInterpolation(this.points.x, e),
                n = this.math.linearInterpolation(this.points.y, e);
            else 1 === this.mode ? (a = this.math.bezierInterpolation(this.points.x, e), n = this.math.bezierInterpolation(this.points.y, e)) : 2 === this.mode && (a = this.math.catmullRomInterpolation(this.points.x, e), n = this.math.catmullRomInterpolation(this.points.y, e));
            var s = {
                x: a,
                y: n,
                angle: 0
            };
            i > 0 && (s.angle = this.math.angleBetweenPoints(this.path[i - 1], s)), this.path.push(s), i++
        }
        return this.mult = this.path.length / 100, this
    }, Phaser.ParticleStorm.Zones.Spline.prototype.getRandom = function() {
        return this.game.rnd.pick(this.path)
    }, Phaser.ParticleStorm.Zones.Spline.prototype.emit = function(t, e, i, r, a) {
        Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        for (var n = null, s = null, o = 0; o < a; o++) n = this.game.rnd.pick(this.path), s = t.emitParticle(e, i + n.x, r + n.y);
        return s
    }, Phaser.ParticleStorm.Zones.Spline.prototype.emitPercent = function(t, e, i, r, a, n) {
        Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        var s = null;
        n = Math.floor(n * this.mult);
        for (var o = 0; o < a; o++) {
            var h = this.path[n];
            h && (s = t.emitParticle(e, i + h.x, r + h.y))
        }
        return s
    }, Phaser.ParticleStorm.Zones.Text = function(t, e) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.bmd = new Phaser.BitmapData(t, "ParticleStorm.Text"), this.text = e, this.points = [], this.update(e)
    }, Phaser.ParticleStorm.Zones.Text.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Text.prototype.constructor = Phaser.ParticleStorm.Zones.Text, Phaser.ParticleStorm.Zones.Text.prototype.update = function(t) {
        void 0 !== t ? this.text = t : t = this.text;
        var e = t.x,
            i = t.y,
            r = t.scale.x,
            a = t.scale.y;
        return t.x = 0, t.y = 0, t.scale.set(1), this.points = [], this.bmd.load(t), this.bmd.processPixelRGB(this.addPixel, this), this.scale = new Phaser.Point(r, a), t.x = e, t.y = i, t.scale.set(r, a), this
    }, Phaser.ParticleStorm.Zones.Text.prototype.addPixel = function(t, e, i) {
        return t.a > this.alphaThreshold && this.points.push({
            x: e,
            y: i,
            color: {
                r: t.r,
                g: t.g,
                b: t.b,
                a: t.a / 255
            }
        }), !1
    }, Phaser.ParticleStorm.Zones.Text.prototype.getRandom = function() {
        var t = this.game.rnd.pick(this.points);
        return t.x *= this.scale.x, t.y *= this.scale.y, t
    }, Phaser.ParticleStorm.Zones.Text.prototype.emit = function(t, e, i, r, a, n, s) {
        Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        for (var o = null, h = null, l = 0; l < a; l++) o = this.game.rnd.pick(this.points), (h = t.emitParticle(e, i + o.x * this.scale.x, r + o.y * this.scale.y)) && (n && o.color.a < 1 && (h.color.alpha.value = o.color.a), s && h.color.setColor(o.color.r, o.color.g, o.color.b, o.color.a));
        return h
    }, Phaser.ParticleStorm.Zones.Text.prototype.emitFull = function(t, e, i, r, a, n, s, o) {
        void 0 === a && (a = 1);
        var h = 1,
            l = 1;
        Array.isArray(n) ? (h = n[0], l = n[1]) : "number" == typeof n && (h = n, l = n), Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        for (var c = null, p = null, m = 0; m < this.points.length; m += a) {
            var u = i + (c = this.points[m]).x * this.scale.x * (h / a),
                d = r + c.y * this.scale.y * (l / a);
            (p = t.emitParticle(e, u, d)) && (s && c.color.a < 1 && (p.color.alpha.value = c.color.a), o && p.color.setColor(c.color.r, c.color.g, c.color.b, c.color.a))
        }
        return p
    }, Phaser.ParticleStorm.Zones.Image = function(t, e) {
        Phaser.ParticleStorm.Zones.Base.call(this, t), this.bmd = new Phaser.BitmapData(t, "ParticleStorm.Image"), this.key = e, this.points = [], this.update(e)
    }, Phaser.ParticleStorm.Zones.Image.prototype = Object.create(Phaser.ParticleStorm.Zones.Base.prototype), Phaser.ParticleStorm.Zones.Image.prototype.constructor = Phaser.ParticleStorm.Zones.Image, Phaser.ParticleStorm.Zones.Image.prototype.update = function(t) {
        return void 0 === t && (t = this.key), this.points = [], this.bmd.load(t), this.bmd.processPixelRGB(this.addPixel, this), this
    }, Phaser.ParticleStorm.Zones.Image.prototype.addPixel = function(t, e, i) {
        return t.a > this.alphaThreshold && this.points.push({
            x: e,
            y: i,
            color: {
                r: t.r,
                g: t.g,
                b: t.b,
                a: t.a / 255
            }
        }), !1
    }, Phaser.ParticleStorm.Zones.Image.prototype.getRandom = function() {
        var t = this.game.rnd.pick(this.points);
        return t.x *= this.scale.x, t.y *= this.scale.y, t
    }, Phaser.ParticleStorm.Zones.Image.prototype.emit = function(t, e, i, r, a, n, s) {
        Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        for (var o = null, h = null, l = 0; l < a; l++) o = this.game.rnd.pick(this.points), (h = t.emitParticle(e, i + o.x * this.scale.x, r + o.y * this.scale.y)) && (n && o.color.a < 1 && (h.color.alpha.value = o.color.a), s && h.color.setColor(o.color.r, o.color.g, o.color.b, o.color.a));
        return h
    }, Phaser.ParticleStorm.Zones.Image.prototype.emitFull = function(t, e, i, r, a, n, s, o) {
        void 0 === a && (a = 1);
        var h = 1,
            l = 1;
        Array.isArray(n) ? (h = n[0], l = n[1]) : "number" == typeof n && (h = n, l = n), Array.isArray(i) && (i = this.game.rnd.between(i[0], i[1])), Array.isArray(r) && (r = this.game.rnd.between(r[0], r[1]));
        for (var c = null, p = null, m = 0; m < this.points.length; m += a) {
            var u = i + (c = this.points[m]).x * this.scale.x * (h / a),
                d = r + c.y * this.scale.y * (l / a);
            (p = t.emitParticle(e, u, d)) && (s && c.color.a < 1 && (p.color.alpha.value = c.color.a), o && p.color.setColor(c.color.r, c.color.g, c.color.b, c.color.a))
        }
        return p
    }, Phaser.ParticleStorm.Controls.Texture = function(t) {
        this.particle = t, this.rnd = t.emitter.game.rnd, this.graph = Phaser.ParticleStorm.Graph, this.sendToBack = !1, this.bringToTop = !0, this.key = null, this.frame = void 0, this.frameName = void 0, this.scaleMode = Phaser.scaleModes.DEFAULT
    }, Phaser.ParticleStorm.Controls.Texture.prototype = {
        reset: function() {
            this.sendToBack = !1, this.bringToTop = !0, this.key = "__default", this.frame = void 0, this.frameName = void 0, this.scaleMode = Phaser.scaleModes.DEFAULT
        },
        init: function(t) {
            if (t.sendToBack ? this.sendToBack = t.sendToBack : t.bringToTop && (this.bringToTop = t.bringToTop), t.image && (Array.isArray(t.image) ? this.key = this.rnd.pick(t.image) : this.key = t.image), void 0 !== t.frame) {
                var e = t.frame;
                Array.isArray(t.frame) && (e = this.rnd.pick(t.frame)), this.graph.isNumeric(e) ? this.frame = e : this.frameName = e
            }
            if (t.scaleMode) {
                var i = t.scaleMode.toUpperCase();
                "LINEAR" === i ? this.scaleMode = Phaser.scaleModes.LINEAR : "NEAREST" === i && (this.scaleMode = Phaser.scaleModes.NEAREST)
            }
        },
        step: function(t, e) {
            if (this.particle.emitter.renderType === Phaser.ParticleStorm.SPRITE && void 0 !== t.animations) {
                var i = [];
                for (var r in t.animations) {
                    var a = t.animations[r],
                        n = null,
                        s = !0;
                    void 0 !== a.frames && "string" == typeof(n = Array.isArray(a.frames) ? a.frames : Phaser.Animation.generateFrameNames(a.frames.prefix, a.frames.start, a.frames.stop, a.frames.suffix, a.frames.zeroPad))[0] && (s = !1);
                    var o = void 0 === a.frameRate ? 60 : a.frameRate,
                        h = void 0 !== a.loop && a.loop;
                    e.animations.add(r, n, o, h, s), i.push(r)
                }
                i.length > 0 && (void 0 !== t.play ? e.play(this.rnd.pick(i)) : e.play(i[0]))
            }
            this.sendToBack ? e.sendToBack() : this.bringToTop && e.bringToTop()
        }
    }, Phaser.ParticleStorm.Controls.Texture.prototype.constructor = Phaser.ParticleStorm.Controls.Texture, Phaser.ParticleStorm.Controls.Color = function(t) {
        this.particle = t, this.graph = Phaser.ParticleStorm.Graph, this.red = {}, this.green = {}, this.blue = {}, this.alpha = {}, this.hsv = {}, this.hsvData = this.particle.emitter.parent.hsv, this.tint = 0, this.isTinted = !1, this.rgba = "rgba(0, 0, 0, 1)", this.blendMode = this.particle.emitter.parent.blendModeMap.NORMAL
    }, Phaser.ParticleStorm.Controls.Color.prototype = {
        reset: function() {
            this.red = Object.create(Phaser.ParticleStorm.BASE_255), this.green = Object.create(Phaser.ParticleStorm.BASE_255), this.blue = Object.create(Phaser.ParticleStorm.BASE_255), this.alpha = Object.create(Phaser.ParticleStorm.BASE_1), this.tint = 16777215, this.isTinted = !1, this.isHSV = !1, this.hsv = Object.create(Phaser.ParticleStorm.BASE_359), this.rgba = "rgba(0, 0, 0, 1)", this.blendMode = this.particle.emitter.parent.blendModeMap.NORMAL
        },
        init: function(t) {
            var e = !1;
            t.hasOwnProperty("hsv") ? ("number" == typeof t.hsv ? this.hsv.value = t.hsv : this.graph.fromData(t.hsv, this.hsv), e = !0, this.isHSV = !0) : (t.hasOwnProperty("red") && ("number" == typeof t.red ? this.red.value = t.red : this.graph.fromData(t.red, this.red), e = !0), t.hasOwnProperty("green") && ("number" == typeof t.green ? this.green.value = t.green : this.graph.fromData(t.green, this.green), e = !0), t.hasOwnProperty("blue") && ("number" == typeof t.blue ? this.blue.value = t.blue : this.graph.fromData(t.blue, this.blue), e = !0)), t.hasOwnProperty("alpha") && ("number" == typeof t.alpha ? this.alpha.value = t.alpha : this.graph.fromData(t.alpha, this.alpha)), this.red.value = Phaser.Math.clamp(this.red.value, 0, 255), this.green.value = Phaser.Math.clamp(this.green.value, 0, 255), this.blue.value = Phaser.Math.clamp(this.blue.value, 0, 255), this.alpha.value = Phaser.Math.clamp(this.alpha.value, 0, 1), this.hsv.value = Phaser.Math.clamp(this.hsv.value, 0, 359), this.particle.emitter.renderType !== Phaser.ParticleStorm.PIXEL && (this.isTinted = e), t.blendMode && (this.blendMode = this.particle.emitter.parent.blendModeMap[t.blendMode.toUpperCase()])
        },
        step: function() {
            var t = this.particle.life;
            this.isHSV ? (this.hsv.value += this.hsv.delta, this.hsv.calc = Phaser.Math.clamp(Math.floor(this.hsv.initial + this.graph.getValue(this.hsv, t)), 0, 359), this.red.value = this.hsvData[this.hsv.calc].r, this.green.value = this.hsvData[this.hsv.calc].g, this.blue.value = this.hsvData[this.hsv.calc].b) : (this.red.value += this.red.delta, this.green.value += this.green.delta, this.blue.value += this.blue.delta), this.red.calc = this.graph.getClampedValue(this.red, t), this.green.calc = this.graph.getClampedValue(this.green, t), this.blue.calc = this.graph.getClampedValue(this.blue, t), this.isTinted && (this.tint = this.red.calc << 16 | this.green.calc << 8 | this.blue.calc), this.alpha.value += this.alpha.delta, this.alpha.calc = Phaser.Math.clamp(this.alpha.initial + this.graph.getValue(this.alpha, t), 0, 1), this.rgba = "rgba(" + this.red.calc + "," + this.green.calc + "," + this.blue.calc + "," + this.alpha.calc + ")"
        },
        setColor: function(t, e, i, r) {
            this.red.value = t, this.green.value = e, this.blue.value = i, this.alpha.value = r, this.particle.emitter.renderType !== Phaser.ParticleStorm.PIXEL && (this.isTinted = !0), this.step()
        }
    }, Phaser.ParticleStorm.Controls.Color.prototype.constructor = Phaser.ParticleStorm.Controls.Color, Phaser.ParticleStorm.Controls.Transform = function(t) {
        this.particle = t, this.time = t.emitter.game.time, this.graph = Phaser.ParticleStorm.Graph, this.x = 0, this.y = 0, this.velocity = {
            x: null,
            y: null,
            facing: null
        }, this.acceleration = {
            x: null,
            y: null,
            facing: null
        }, this.scale = {
            x: null,
            y: null
        }, this.rotation = {}, this.anchor = new Phaser.Point
    }, Phaser.ParticleStorm.Controls.Transform.prototype = {
        reset: function() {
            this.velocity.x = Object.create(Phaser.ParticleStorm.BASE), this.velocity.y = Object.create(Phaser.ParticleStorm.BASE), this.velocity.facing = Object.create(Phaser.ParticleStorm.BASE_NULL), this.acceleration.x = Object.create(Phaser.ParticleStorm.BASE), this.acceleration.y = Object.create(Phaser.ParticleStorm.BASE), this.acceleration.facing = Object.create(Phaser.ParticleStorm.BASE_NULL), this.scale.x = Object.create(Phaser.ParticleStorm.BASE_1), this.scale.y = Object.create(Phaser.ParticleStorm.BASE_1), this.rotation = Object.create(Phaser.ParticleStorm.BASE), this.anchor.set(.5)
        },
        init: function(t, e, i) {
            if (this.x = t, this.y = e, i.hasOwnProperty("anchor") ? this.anchor.set(i.anchor) : (i.hasOwnProperty("anchorX") && (this.anchor.x = i.anchorX), i.hasOwnProperty("anchorY") && (this.anchor.y = i.anchorY)), i.hasOwnProperty("velocity")) {
                if (this.graph.isNumeric(i.velocity)) this.velocity.x.value = i.velocity, this.velocity.y.value = i.velocity;
                else if (i.velocity.hasOwnProperty("min")) this.velocity.x.value = this.graph.getMinMax(i.velocity), this.velocity.y.value = this.velocity.x.value;
                else if (i.velocity.radial) {
                    var r = this.graph.getMinMaxInitial(i.velocity),
                        a = i.velocity.radial.arcStart,
                        n = i.velocity.radial.arcEnd;
                    if (void 0 !== a && void 0 !== n) {
                        var s = (Math.random() * (n - a) + a) * Math.PI / 180,
                            o = Math.sin(s),
                            h = -Math.cos(s);
                        this.velocity.x.value = o * r, this.velocity.y.value = h * r
                    }
                } else this.velocity.x.initial = this.graph.getMinMaxInitial(i.velocity), this.velocity.y.initial = this.velocity.x.initial, this.velocity.x.value = this.graph.getMinMax(i.velocity.value), this.velocity.y.value = this.velocity.x.value;
                i.velocity.hasOwnProperty("delta") && (this.velocity.x.delta = this.graph.getMinMax(i.velocity.delta), this.velocity.y.delta = this.velocity.x.delta), i.velocity.hasOwnProperty("control") && (this.velocity.x.control = i.velocity.control, this.velocity.y.control = i.velocity.control), i.hasOwnProperty("vx") && this.graph.fromData(i.vx, this.velocity.x), i.hasOwnProperty("vy") && this.graph.fromData(i.vy, this.velocity.y)
            } else i.hasOwnProperty("target") ? this.particle.target(i.target) : ("number" == typeof i.vx ? this.velocity.x.value = i.vx : this.graph.fromData(i.vx, this.velocity.x), "number" == typeof i.vy ? this.velocity.y.value = i.vy : this.graph.fromData(i.vy, this.velocity.y));
            "number" == typeof i.facingVelocity ? this.velocity.facing.value = i.facingVelocity : this.graph.fromData(i.facingVelocity, this.velocity.facing), "number" == typeof i.facingAcceleration ? this.acceleration.facing.value = i.facingAcceleration : this.graph.fromData(i.facingAcceleration, this.acceleration.facing), i.hasOwnProperty("acceleration") ? (this.graph.fromData(i.acceleration, this.acceleration.x), this.graph.fromData(i.acceleration, this.acceleration.y)) : ("number" == typeof i.ax ? this.acceleration.x.value = i.ax : this.graph.fromData(i.ax, this.acceleration.x), "number" == typeof i.ay ? this.acceleration.y.value = i.ay : this.graph.fromData(i.ay, this.acceleration.y)), i.hasOwnProperty("scale") ? (this.graph.fromData(i.scale, this.scale.x), this.graph.clone(this.scale.x, this.scale.y)) : ("number" == typeof i.scaleX ? this.scale.x.value = i.scaleX : this.graph.fromData(i.scaleX, this.scale.x), "number" == typeof i.scaleY ? this.scale.y.value = i.scaleY : this.graph.fromData(i.scaleY, this.scale.y)), "number" == typeof i.rotation ? this.rotation.value = i.rotation : this.graph.fromData(i.rotation, this.rotation);
            var l = this.particle.parent;
            l && l.emit && l.emit.inherit && this.inherit(l)
        },
        inherit: function(t) {
            var e = t.emit.inherit,
                i = !1;
            if ("boolean" == typeof e && (i = !0), (i || e.vx || e.velocity) && this.graph.clone(t.transform.velocity.x, this.velocity.x), (i || e.vy || e.velocity) && this.graph.clone(t.transform.velocity.y, this.velocity.y), (i || e.facingVelocity) && this.graph.clone(t.transform.velocity.facing, this.velocity.facing), (i || e.scaleX || e.scale) && this.graph.clone(t.transform.scale.x, this.scale.x), (i || e.scaleY || e.scale) && this.graph.clone(t.transform.scale.y, this.scale.y), (i || e.rotation) && this.graph.clone(t.transform.rotation, this.rotation), e.angularVelocity) {
                var r = (t.transform.rotation.initial + t.transform.rotation.value) * Math.PI / 180;
                this.velocity.x.initial = Math.sin(r), this.velocity.y.initial = -Math.cos(r)
            }
        },
        step: function() {
            var t = this.particle.life;
            if (this.scale.x.value += this.scale.x.delta * this.particle.particleScale.x, this.scale.y.value += this.scale.y.delta * this.particle.particleScale.y, this.rotation.value += this.rotation.delta, this.rotation.calc = (this.rotation.initial + this.graph.getValue(this.rotation, t)) * Math.PI / 180, this.scale.x.calc = (this.scale.x.initial + this.graph.getValue(this.scale.x, t)) * this.particle.particleScale.x, this.scale.y.calc = (this.scale.y.initial + this.graph.getValue(this.scale.y, t)) * this.particle.particleScale.y, 0 !== t) {
                var e = 0,
                    i = 0;
                null !== this.acceleration.facing.value && (this.acceleration.facing.value += this.acceleration.facing.delta, e = this.rotation.calc + (90 + this.acceleration.facing.offset) * Math.PI / 180, i = this.acceleration.facing.initial + this.graph.getValue(this.acceleration.facing, t), this.velocity.x.value += i * Math.sin(e), this.velocity.y.value += i * -Math.cos(e)), this.acceleration.x.value += this.acceleration.x.delta, this.acceleration.y.value += this.acceleration.y.delta, this.velocity.x.value += this.velocity.x.delta + this.acceleration.x.initial + this.graph.getValue(this.acceleration.x, t), this.velocity.y.value += this.velocity.y.delta + this.acceleration.y.initial + this.graph.getValue(this.acceleration.y, t), null !== this.velocity.facing.value && (this.velocity.facing.value += this.velocity.facing.delta, e = this.rotation.calc + (90 + this.velocity.facing.offset) * Math.PI / 180, i = this.velocity.facing.initial + this.graph.getValue(this.velocity.facing, t), this.x += i * Math.sin(e), this.y += i * -Math.cos(e)), this.x += (this.velocity.x.initial + this.graph.getValue(this.velocity.x, t)) * this.particle.particleScale.x, this.y += (this.velocity.y.initial + this.graph.getValue(this.velocity.y, t)) * this.particle.particleScale.y
            }
        }
    }, Phaser.ParticleStorm.Controls.Transform.prototype.constructor = Phaser.ParticleStorm.Controls.Transform, Phaser.ParticleStorm.Renderer = {}, Phaser.ParticleStorm.Renderer.Base = function(t) {
        this.game = t.game, this.emitter = t, this.parent = t.parent, this.pixelSize = 1
    }, Phaser.ParticleStorm.Renderer.Base.prototype = {
        addToWorld: function(t) {
            return t.add(this.display), this.display
        },
        preUpdate: function() {},
        add: function() {
            return null
        },
        update: function(t) {
            return t
        },
        postUpdate: function() {},
        kill: function(t) {
            return t
        },
        destroy: function() {
            this.game = null
        }
    }, Phaser.ParticleStorm.Renderer.Base.prototype.constructor = Phaser.ParticleStorm.Renderer.Base, Phaser.ParticleStorm.Renderer.Sprite = function(t) {
        Phaser.ParticleStorm.Renderer.Base.call(this, t), this.display = this.game.make.group(null, "particleStormSpriteRenderer")
    }, Phaser.ParticleStorm.Renderer.Sprite.prototype = Object.create(Phaser.ParticleStorm.Renderer.Base.prototype), Phaser.ParticleStorm.Renderer.Sprite.prototype.constructor = Phaser.ParticleStorm.Renderer.Sprite, Phaser.ParticleStorm.Renderer.Sprite.prototype.add = function(t) {
        var e = t.sprite,
            i = t.texture.key,
            r = t.texture.frame;
        return void 0 === r && void 0 !== t.texture.frameName && (r = t.texture.frameName), e ? (e.reset(t.transform.x, t.transform.y), e.key !== i ? e.loadTexture(i, r) : void 0 !== t.texture.frame ? e.frame = r : void 0 !== t.texture.frameName && (e.frameName = r)) : e = this.display.create(t.transform.x, t.transform.y, i, r), e.anchor.set(t.transform.anchor.x, t.transform.anchor.y), t.color.isTinted && (e.tint = t.color.tint), e.blendMode = t.color.blendMode[0], e.texture.baseTexture.scaleMode = t.texture.scaleMode, e.visible = t.visible, t.sprite = e, e
    }, Phaser.ParticleStorm.Renderer.Sprite.prototype.update = function(t) {
        var e = t.sprite;
        t.delay > 0 && !t.delayVisible ? e.visible = !1 : (e.visible = t.visible, e.alpha = t.color.alpha.calc, e.rotation = t.transform.rotation.calc, t.color.isTinted && (e.tint = t.color.tint), e.scale.setTo(t.transform.scale.x.calc, t.transform.scale.y.calc), e.x = t.transform.x, e.y = t.transform.y)
    }, Phaser.ParticleStorm.Renderer.Sprite.prototype.kill = function(t) {
        t.sprite && t.sprite.kill()
    }, Phaser.ParticleStorm.Renderer.Sprite.prototype.destroy = function() {
        this.display.destroy(!0), this.emitter = null, this.game = null
    }, Phaser.ParticleStorm.Renderer.Pixel = function(t, e, i) {
        Phaser.ParticleStorm.Renderer.Base.call(this, t), this.bmd = this.game.make.bitmapData(e, i), this.display = this.game.make.image(0, 0, this.bmd), this.autoClear = !0
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype = Object.create(Phaser.ParticleStorm.Renderer.Base.prototype), Phaser.ParticleStorm.Renderer.Pixel.prototype.constructor = Phaser.ParticleStorm.Renderer.Pixel, Phaser.ParticleStorm.Renderer.Pixel.prototype.resize = function(t, e) {
        return this.bmd.resize(t, e), this
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype.clear = function(t) {
        return this.bmd.fill(0, 0, 0, t), this.bmd.update(), this
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype.preUpdate = function() {
        this.autoClear && (this.bmd.clear(), this.bmd.update())
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype.update = function(t) {
        if (!(t.delay > 0) || t.delayVisible) {
            var e = Math.floor(t.transform.x),
                i = Math.floor(t.transform.y),
                r = t.color.red.calc,
                a = t.color.green.calc,
                n = t.color.blue.calc,
                s = Math.floor(255 * t.color.alpha.calc);
            this.pixelSize > 2 ? this.bmd.rect(e, i, this.pixelSize, this.pixelSize, t.color.rgba) : (this.bmd.setPixel32(e, i, r, a, n, s, !1), 2 === this.pixelSize && (this.bmd.setPixel32(e + 1, i, r, a, n, s, !1), this.bmd.setPixel32(e, i + 1, r, a, n, s, !1), this.bmd.setPixel32(e + 1, i + 1, r, a, n, s, !1)))
        }
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype.postUpdate = function() {
        this.pixelSize <= 2 && this.bmd.context.putImageData(this.bmd.imageData, 0, 0), this.bmd.dirty = !0
    }, Phaser.ParticleStorm.Renderer.Pixel.prototype.destroy = function() {
        this.game = null, this.display.destroy(), this.bmd.destroy()
    }, Phaser.ParticleStorm.Renderer.BitmapData = function(t, e, i) {
        Phaser.ParticleStorm.Renderer.Base.call(this, t), this.bmd = this.game.make.bitmapData(e, i), this.display = this.game.make.image(0, 0, this.bmd), this.roundPx = !0, this.autoClear = !0
    }, Phaser.ParticleStorm.Renderer.BitmapData.prototype = Object.create(Phaser.ParticleStorm.Renderer.Base.prototype), Phaser.ParticleStorm.Renderer.BitmapData.prototype.constructor = Phaser.ParticleStorm.Renderer.BitmapData, Phaser.ParticleStorm.Renderer.BitmapData.prototype.resize = function(t, e) {
        return this.bmd.resize(t, e), this
    }, Phaser.ParticleStorm.Renderer.BitmapData.prototype.clear = function(t) {
        return this.bmd.fill(0, 0, 0, t), this
    }, Phaser.ParticleStorm.Renderer.BitmapData.prototype.preUpdate = function() {
        this.autoClear && this.bmd.clear()
    }, Phaser.ParticleStorm.Renderer.BitmapData.prototype.update = function(t) {
        if (!(t.delay > 0) || t.delayVisible) {
            var e = t.transform;
            this.bmd.copy(t.texture.key, 0, 0, null, null, e.x, e.y, null, null, e.rotation.calc, e.anchor.x, e.anchor.y, e.scale.x.calc, e.scale.y.calc, t.color.alpha.calc, t.color.blendMode[1], this.roundPx)
        }
    }, Phaser.ParticleStorm.Renderer.BitmapData.prototype.destroy = function() {
        this.game = null, this.display.destroy(), this.bmd.destroy()
    }, Phaser.ParticleStorm.Renderer.RenderTexture = function(t, e, i) {
        Phaser.ParticleStorm.Renderer.Base.call(this, t), this.renderTexture = this.game.make.renderTexture(e, i), this.display = this.game.make.image(0, 0, this.renderTexture), this.stamp = this.game.make.image(0, 0), this.autoClear = !0
    }, Phaser.ParticleStorm.Renderer.RenderTexture.prototype = Object.create(Phaser.ParticleStorm.Renderer.Base.prototype), Phaser.ParticleStorm.Renderer.RenderTexture.prototype.constructor = Phaser.ParticleStorm.Renderer.RenderTexture, Phaser.ParticleStorm.Renderer.RenderTexture.prototype.clear = function() {
        this.renderTexture.clear()
    }, Phaser.ParticleStorm.Renderer.RenderTexture.prototype.preUpdate = function() {
        this.autoClear && this.renderTexture.clear()
    }, Phaser.ParticleStorm.Renderer.RenderTexture.prototype.update = function(t) {
        if (!(t.delay > 0 && !t.delayVisible || !t.visible || 0 === t.color.alpha.calc)) {
            var e = t.texture.key,
                i = t.texture.frame;
            void 0 === i && void 0 !== t.texture.frameName && (i = t.texture.frameName), this.stamp.key !== e ? this.stamp.loadTexture(e, i) : void 0 !== t.texture.frame ? this.stamp.frame = i : void 0 !== t.texture.frameName && (this.stamp.frameName = i), this.stamp.anchor.set(t.transform.anchor.x, t.transform.anchor.y), this.stamp.alpha = t.color.alpha.calc, this.stamp.rotation = t.transform.rotation.calc, t.color.isTinted && (this.stamp.tint = t.color.tint), this.stamp.blendMode = t.color.blendMode[0], this.stamp.texture.baseTexture.scaleMode = t.texture.scaleMode, this.stamp.scale.setTo(t.transform.scale.x.calc, t.transform.scale.y.calc), this.renderTexture.renderXY(this.stamp, t.transform.x, t.transform.y, !1)
        }
    }, Phaser.ParticleStorm.Renderer.RenderTexture.prototype.destroy = function() {
        this.display.destroy(), this.stamp.destroy(), this.renderTexture.destroy(), this.emitter = null, this.game = null
    }, Phaser.ParticleStorm.Renderer.SpriteBatch = function(t) {
        Phaser.ParticleStorm.Renderer.Base.call(this, t), this.display = this.game.make.spriteBatch()
    }, Phaser.ParticleStorm.Renderer.SpriteBatch.prototype = Object.create(Phaser.ParticleStorm.Renderer.Base.prototype), Phaser.ParticleStorm.Renderer.SpriteBatch.prototype.constructor = Phaser.ParticleStorm.Renderer.SpriteBatch, Phaser.ParticleStorm.Renderer.SpriteBatch.prototype.add = function(t) {
        var e = t.sprite,
            i = t.texture.key,
            r = t.texture.frame;
        return void 0 === r && void 0 !== t.texture.frameName && (r = t.texture.frameName), e ? (e.reset(t.transform.x, t.transform.y), e.key !== i ? e.loadTexture(i, r) : void 0 !== t.texture.frame ? e.frame = r : void 0 !== t.texture.frameName && (e.frameName = r)) : e = this.game.make.sprite(t.transform.x, t.transform.y, i, r), this.display.addChild(e), e.anchor.set(t.transform.anchor.x, t.transform.anchor.y), t.color.isTinted && (e.tint = t.color.tint), e.blendMode = t.color.blendMode[0], e.texture.baseTexture.scaleMode = t.texture.scaleMode, e.visible = t.visible, t.sprite = e, e
    }, Phaser.ParticleStorm.Renderer.SpriteBatch.prototype.update = function(t) {
        var e = t.sprite;
        t.delay > 0 && !t.delayVisible ? e.visible = !1 : (e.visible = t.visible, e.alpha = t.color.alpha.calc, e.rotation = t.transform.rotation.calc, t.color.isTinted && (e.tint = t.color.tint), e.scale.setTo(t.transform.scale.x.calc, t.transform.scale.y.calc), e.x = t.transform.x, e.y = t.transform.y)
    }, Phaser.ParticleStorm.Renderer.SpriteBatch.prototype.kill = function(t) {
        t.sprite && t.sprite.kill()
    }, Phaser.ParticleStorm.Renderer.SpriteBatch.prototype.destroy = function() {
        this.display.destroy(!0), this.emitter = null, this.game = null
    };